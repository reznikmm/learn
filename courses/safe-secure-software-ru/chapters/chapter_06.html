<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Безопасное создание объектов &mdash; learn.adacore.com</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/style.6b9ffa6b650d4d2b2239.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/1.style.6b9ffa6b650d4d2b2239.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/main.6b9ffa6b650d4d2b2239.js"></script>
        <script src="../../../_static/1.main.6b9ffa6b650d4d2b2239.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Безопасное управление памятью" href="chapter_07.html" />
    <link rel="prev" title="Безопасное объектно-ориентированное программирование" href="chapter_05.html" />
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-117428-14"></script>
<script type="text/javascript">
  if(!Cookies.get('AdaCore_staff')) {
    // Global site tag (gtag.js) - Google Analytics
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-117428-14');
    // End Global site tag (gtag.js) - Google Analytics

    // Google Tag Manager
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KD5HNRR');
    // End Google Tag Manager

    // Twitter universal website tag code
    !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
    // Insert Twitter Pixel ID and Standard Event data below
    twq('init','o3mlc');
    twq('track','PageView');
    // End Twitter universal website tag code

    // LinkedIn Tracking Tags
    _linkedin_partner_id = "482585"; window._linkedin_data_partner_ids = window._linkedin_data_partner_ids || []; window._linkedin_data_partner_ids.push(_linkedin_partner_id);
    (function(){var s = document.getElementsByTagName("script")[0]; var b = document.createElement("script"); b.type = "text/javascript";b.async = true; b.src = "https://snap.licdn.com/li.lms-analytics/insight.min.js"; s.parentNode.insertBefore(b, s);})();
    // End LinkedIn Tracking Tags
  }
</script>
  <!--  Essential META Tags -->
<meta property="og:title" content=“learn.adacore.com">
<meta property="og:description" content="An interactive learning platform to teach the Ada and SPARK programming languages.">
<meta property="og:image" content="https://learn.adacore.com/_static/learn_meta_img.jpeg">
<meta property="og:url" content="https://learn.adacore.com">
<meta name="twitter:card" content="summary_large_image">

<!--  Non-Essential, But Recommended -->
<meta property="og:site_name" content="learn.adacore.com">
<meta name="twitter:image:alt" content="An interactive learning platform to teach the Ada and SPARK programming languages.">

<!--  Non-Essential, But Required for Analytics -->
<meta name="twitter:site" content="@AdaCoreCompany">

</head>

<body class="wy-body-for-nav">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KD5HNRR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <!-- LinkedIn Tracking Tags (noscript) -->
  <noscript> <img height="1" width="1" style="display:none;" alt="" src="https://dc.ads.linkedin.com/collect/?pid=482585&fmt=gif" /> </noscript>
  <!-- End LinkedIn Tracking Tags (noscript) -->

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">Подробнее</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Курсы</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../intro-to-ada-ru/index.html">Введение в язык Ада</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html">Введение</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id2">История</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id3">Ада сегодня</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id7">Философия</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#spark">SPARK</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html">Императивы языка</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#hello-world">Hello world</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id2">Условный оператор</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id3">Циклы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#for">Циклы for</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id4">Простой цикл</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#while">Циклы while</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id5">Оператор выбора</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id6">Зоны описания</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id7">Условные выражения</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id8">Условное выражение</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id9">Выражение выбора</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html">Подпрограммы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id2">Подпрограммы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id3">Вызовы подпрограмм</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id4">Вложенные подпрограммы</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id5">Вызов функций</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id6">Виды параметров</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id7">Вызов процедуры</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#in">Параметры in</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#in-out">Параметры in out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#out">Параметры out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id8">Предварительное объявление подпрограмм</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#intro-ada-ru-subprogram-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html">Модульное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id2">Пакеты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-use-clause">Использование пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id4">Тело пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-childpackages">Дочерние пакеты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id6">Дочерний пакет от дочернего пакета</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id7">Множественные потомки</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id8">Видимость</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-package-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html">Сильно типизированный язык</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-whatisatype">Что такое тип?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#integers">Целочисленные типы - Integers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id3">Семантика операций</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id4">Беззнаковые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-enumtypes">Перечисления</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id7">Типы с плавающей запятой</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id8">Основные свойства</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id9">Точность типов с плавающей запятой</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id10">Диапазон значений для типов с плавающей запятой</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id11">Строгая типизация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id12">Производные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id13">Подтипы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-subtypealiases">Подтипы в качестве псевдонимов типов</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html">Записи</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#intro-ada-ru-record-type-declaration">Объявление типа записи</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#id3">Агрегаты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#id4">Извлечение компонент</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#record-comp-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html">Массивы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id2">Объявление типа массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id3">Доступ по индексу</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id4">Более простые объявления массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id5">Атрибут диапазона</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#intro-ada-ru-unconstrainedarraytypes">Неограниченные массивы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#string">Предопределенный тип String</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id7">Ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id8">Возврат неограниченных массивов</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id9">Объявление массивов (2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id10">Отрезки массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#intro-ada-ru-object-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html">Подробнее о типах</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#id2">Агрегаты: краткая информация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#c">Cовмещение и квалифицированные выражения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#id4">Символьные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html">Ссылочные типы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id2">Введение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#allocation">Выделение (allocation) памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#intro-ada-ru-access-dereferencing">Извлечение по ссылке</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id4">Другие особенности</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id5">Взаимно рекурсивные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html">Подробнее о записях</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#id2">Типы записей динамически изменяемого размера</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#id3">Записи с дискриминантом</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#c">Записи c вариантами</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html">Типы с фиксированной запятой</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html#id2">Десятичные типы с фиксированной запятой</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html#id3">Обычные типы с фиксированной запятой</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html">Изоляция</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id3">Простейшая инкапсуляция</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id4">Абстрактные типы данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id5">Лимитируемые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id7">Дочерние пакеты и изоляция</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html">Настраиваемые модули</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id2">Введение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id3">Объявление формального типа</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id4">Объявление формального объекта</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id5">Определение тела настраиваемого модуля</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id6">Конкретизация настройки</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id7">Настраиваемые пакеты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id8">Формальные подпрограммы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id9">Пример: конкретизация ввода/вывода</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id10">Пример: АТД</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id11">Пример: Обмен</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id12">Пример: Обратный порядок элементов</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id13">Пример: Тестовое приложение</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html">Исключения</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id2">Объявление исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id3">Возбуждение исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id4">Обработка исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id5">Предопределенные исключения</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html">Управление задачами</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id2">Задачи</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id5">Простая задача</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id6">Простая синхронизация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id7">Оператор задержки</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id8">Синхронизация: рандеву</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id9">Обрабатывающий цикл</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id10">Циклические задачи</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id11">Защищенные объекты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id12">Простой объект</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id13">Входы</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id14">Задачные и защищенные типы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#intro-ada-ru-tasktypes">Задачные типы</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id16">Защищенные типы</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html">Контрактное проектирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id2">Пред- и постусловия</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id3">Предикаты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id4">Инварианты типа</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html">Взаимодействие с языком C</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id1">Многоязычный проект</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id2">Соглашение о типах</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id3">Подпрограммы на других языках</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id4">Вызов подпрограмм C из Ады</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id5">Вызов Ада подпрограмм из C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id6">Внешние переменные</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id7">Использование глобальных переменных C в Аде</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id8">Использование переменных Ада в C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id9">Автоматическое создание связок</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id10">Адаптация связок</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html">Объектно-ориентированное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id2">Производные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id3">Теговые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id5">Надклассовые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id6">Операции диспетчеризации</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id7">Точечная нотация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id8">Личные и лимитируемые типы с тегами</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id9">Надклассовые ссылочные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html">Стандартная библиотека: Контейнеры</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id2">Векторы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id3">Создание экземпляра</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id4">Инициализация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id5">Добавление элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id6">Доступ к первому и последнему элементам</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id7">Итерация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id8">Поиск и изменение элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id9">Вставка элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id10">Удаление элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id11">Другие операции</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id12">Множества</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id13">Инициализация и итерация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id14">Операции с элементами</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id15">Другие операции</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id16">Отображения для неопределенных типов</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id17">Хэшированные отображения</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id18">Упорядоченные отображения</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id19">Сложность</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html">Стандартная библиотека: Дата и время</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#intro-ada-ru-datestimes">Обработка даты и времени</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id3">Задержка с использованием даты</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id4">Режим реального времени</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id5">Анализ производительности</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html">Стандартная библиотека: Строки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id2">Операции со строками</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id3">Ограничение строк фиксированной длины</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id4">Ограниченные строки</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#intro-ada-ru-unboundedstrings">Неограниченные строки</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html">Стандартная библиотека: Файлы и потоки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id2">Текстовый ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id3">Последовательный ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id4">Прямой ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id5">Потоковый ввод-вывод</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html">Стандартная библиотека: Numerics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id1">Элементарные функции</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id2">Генерация случайных чисел</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id3">Комплексные числа</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id4">Работа с векторами и матрицами</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html">Приложения</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#a">Приложение A: Формальные типы настройки</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#id2">Неопределенные версии типов</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#b">Приложение B: Контейнеры</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Безопасное и надежное программное обеспечение</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Вступление</a></li>
<li class="toctree-l2"><a class="reference internal" href="foreword.html">Предисловие</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_01.html">Безопасный синтаксис</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id2">Присваивание и проверка на равенство</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id3">Группы инструкций</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id4">Именованное сопоставление</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id5">Целочисленные литералы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_02.html">Безопасные типы данных</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id2">Использование индивидуальных типов</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id3">Перечисления и целые</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id4">Ограничения и подтипы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id5">Предикаты подтипов</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id6">Массивы и ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id7">Установка начальных значений по умолчанию</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id8">«Вещественные ошибки»</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_03.html">Безопасные указатели</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id2">Ссылки, указатели и адреса</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id3">Ссылочные типы и строгая типизация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id4">Ссылочные типы и контроль доступности</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id5">Ссылки на подпрограммы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id6">Вложенные подпрограммы в качестве параметров</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_04.html">Безопасная архитектура</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id2">Спецификация и тело пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id3">Приватные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id4">Контрактная модель настраиваемых модулей</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id5">Дочерние модули</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id6">Модульное тестирование</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id7">Взаимозависимые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id8">Контрактное программирование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_05.html">Безопасное объектно‐ориентированное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id2">ООП вместо структурного программирования</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#overriding">Индикатор overriding</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id3">Запрет диспетчеризации вызова подпрограмм</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id4">Интерфейсы и множественное наследование</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id5">Взаимозаменяемость</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Безопасное создание объектов</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Переменные и константы</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Функция-конструктор</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Лимитируемые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Контролируемые типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_07.html">Безопасное управление памятью</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id2">Переполнение буфера</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id3">Динамическое распределение памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id4">Пулы памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id5">Ограничения</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_08.html">Безопасный запуск</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id2">Предвыполнение</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id3">Директивы компилятору, связанные с предвыполнением</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id4">Динамическая загрузка</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_09.html">Безопасная коммуникация</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id2">Представление данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id3">Корректность данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id4">Взаимодействие с другими языками</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id5">Потоки ввода/вывода</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id6">Фабрики объектов</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_10.html">Безопасный параллелизм</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id2">Операционные системы и задачи</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id3">Защищенные объекты</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id4">Рандеву</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id5">Ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#ravenscar">Ravenscar</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id6">Безопасное завершение</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id7">Время и планирование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_11.html">Сертификация с помощью SPARK</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id1">Контракты</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id2">SPARK — подмножество языка Ада</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id3">Формальные методы анализа</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id4">Гибридная верификация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id5">Примеры</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id6">Сертификация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id7">Дальнейший процесс</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html">Заключение</a></li>
<li class="toctree-l2"><a class="reference internal" href="biblio.html">Список литературы</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
  <i data-toggle="wy-nav-top" class="fas fa-bars"></i>
    <a href="../../../index.html">
    <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
  </a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>Безопасное создание объектов<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>Эта глава раскрывает некоторые аспекты управления объектами. Под
объектами здесь мы понимаем как мелкие объекты в виде простых констант и
переменных элементарного типа, например Integer, так и большие объекты
из области ООП.</p>
<p>Язык Ада предоставляет развитые и гибкие инструменты в этой области. Эти
инструменты, главным образом, не являются обязательными, но хороший
программист использует их по-возможности, а хороший менеджер настаивает
на их использовании по-возможности.</p>
<section id="id2">
<h2>Переменные и константы<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>Как мы уже видели, мы можем определить переменные и константы, написав:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Top</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>  <span class="c1">--  переменная</span>

<span class="no">Max</span> <span class="p">:</span> <span class="kr">constant</span> <span class="kt">Integer</span> <span class="p">:=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">--  константа</span>
</pre></div>
</div>
<p>соответственно. Top - это переменная и мы можем присваивать ей новые
значения, в то время как Max - это константа и ее значение не может быть
изменено. Заметьте, что в определении константы задавать начальное
значение необходимо. Переменным тоже можно задать начальное значение, но
это не обязательно.</p>
<p>Преимущество констант в том, что их нельзя нечаянно изменить. Эта
конструкция не только удобный «предохранитель». Она также помогает
каждому, кто читает программу, сразу обозначая статус объекта. Важная
деталь тут в том, что значение не обязательно должно быть статическим,
т. е. известным в момент компиляции. В качестве примера приведем код
вычисления процентных ставок:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Nfv_2000</span> <span class="p">(</span><span class="nv">X</span><span class="p">: </span><span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="no">Factor</span><span class="p">:</span> <span class="kr">constant</span> <span class="kt">Float</span> <span class="p">:=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">X</span><span class="o">/</span><span class="mf">100.0</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="kr">return</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">Factor</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">500.0</span> <span class="o">*</span> <span class="n">Factor</span> <span class="o">-</span> <span class="mf">2000.00</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Nfv_2000</span><span class="p">;</span>
</pre></div>
</div>
<p>Каждый вызов функции Nfv_2000 получает новое значение X и,
следовательно, новое значение Factor. Но Factor не изменяется в течении
одного вызова. Хотя этот пример тривиальный и легко видеть, что Factor
не изменяется, необходимо выработать привычку использовать constant
везде, где это возможно.</p>
<p>Параметры подпрограммы это еще один пример концепции переменных и
констант.</p>
<p>Параметры бывают трех видов: in, in out и out. Если вид не указан в
тексте, то, по умолчанию, используется in. В версиях языка вплоть до Ада
2005 включительно функции могли иметь параметры только вида in. Это
ограничение имело методологический характер, чтобы склонить программиста
не писать функции, имеющие побочные эффекты. На практике, однако, это
ограничение на самом деле не работает. Создать функцию, имеющую побочные
эффекты, легко, достаточно использовать ссылочный параметр или
присваивание нелокальной переменной. Более того, в случае, когда
побочный эффект необходим, программист был лишен возможности обозначить
это явно, использовав подходящий вид параметра. Учитывая вышесказанное,
стандарт Ада 2012, наконец, разрешил функциям иметь параметры всех трех
видов.</p>
<p>Параметр вида in это константа, получающая значение аргумента вызова
подпрограммы. Таким образом, X, из примера с Nfv_2000, имеет вид in и
поэтому является константой, т. е. мы не можем присвоить ей значение и у
нас есть гарантия, что ее значение не меняется. Соответствующий аргумент
может быть любым выражением требуемого типа.</p>
<p>Параметры вида in out и out являются переменными. Аргумент вызова также
должен быть переменной. Различие между этими видами касается начального
значения. Параметр вида in out принимает начальное значение аргумента, в
то время как параметр вида out не имеет начального значения (либо оно
задается начальным значением, определенным самим типом параметра,
например null для ссылочных типов).</p>
<p>Примеры использования всех трех видов параметров мы встречали в
определении процедур Push и Pop в главе «Безопасная Архитектура»:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Push</span> <span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">in</span> <span class="nv">Float</span><span class="p">);</span>

<span class="kd">procedure</span> <span class="nf">Pop</span> <span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Float</span><span class="p">);</span>
</pre></div>
</div>
<p>Правила, касающиеся аргументов подпрограмм, гарантируют, что свойство
«константности» не нарушается. Мы не можем передать константы, такие как
Factor, при вызове Pop, поскольку соответствующий параметр имеет вид
out. В противном случае это дало бы возможность Pop поменять значение
Factor.</p>
<p>Различие между константами и переменными также затрагивает ссылочные
типы и объекты. Так, если мы имеем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Int_Ptr</span> <span class="kr">is</span> <span class="kr">access</span> <span class="kr">all</span> <span class="kt">Integer</span><span class="p">;</span>

<span class="n">K</span><span class="p">:</span> <span class="kr">aliased</span> <span class="kt">Integer</span><span class="p">;</span>

<span class="n">KP</span><span class="p">:</span> <span class="n">Int_Ptr</span> <span class="p">:=</span> <span class="n">K</span><span class="p">&#39;</span><span class="na">Access</span><span class="p">;</span>

<span class="no">CKP</span><span class="p">:</span> <span class="kr">constant</span> <span class="n">Int_Ptr</span> <span class="p">:=</span> <span class="n">K</span><span class="p">&#39;</span><span class="na">Access</span><span class="p">;</span>
</pre></div>
</div>
<p>то значение KP можно изменить, а значение CKP — нет. Хотя мы не можем
заставить CKP ссылаться на другой объект, мы можем поменять значение K:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">CKP</span><span class="p">.</span><span class="kr">all</span> <span class="p">:=</span> <span class="mi">47</span><span class="p">;</span>  <span class="c1">-- установить значение K равным 47</span>
</pre></div>
</div>
<p>С другой стороны:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Const_Int_Ptr</span> <span class="kr">is</span> <span class="kr">access</span> <span class="kr">constant</span> <span class="kt">Integer</span><span class="p">;</span>

<span class="n">J</span><span class="p">:</span> <span class="kr">aliased</span> <span class="kt">Integer</span><span class="p">;</span>

<span class="n">JP</span><span class="p">:</span> <span class="n">Const_Int_Ptr</span> <span class="p">:=</span> <span class="n">J</span><span class="p">&#39;</span><span class="na">Access</span><span class="p">;</span>

<span class="no">CJP</span><span class="p">:</span> <span class="kr">constant</span> <span class="n">Const_Int_Ptr</span> <span class="p">:=</span> <span class="n">J</span><span class="p">&#39;</span><span class="na">Access</span><span class="p">;</span>
</pre></div>
</div>
<p>где мы используем constant в описании типа. Это значит, мы не можем
поменять значение объекта J, используя ссылки JP и CJP. Переменная JP
может ссылаться на различные объекты, в то время, как CJP ссылается
только на J.</p>
<p>Вид только-для-чтения и для чтения-записи</p>
<p>Иногда необходимо разрешить клиенту читать переменную без возможности
изменять ее. Другими словами, нужно предоставить вид только-для-чтения
для данной переменной. Это можно сделать при помощи отложенной константы
и ссылочного типа:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">P</span> <span class="kr">is</span>
   <span class="kd">type</span> <span class="kt">Const_Int_Ptr</span> <span class="kr">is</span> <span class="kr">access</span> <span class="kr">constant</span> <span class="kt">Integer</span><span class="p">;</span>
   <span class="no">The_Ptr</span><span class="p">:</span> <span class="kr">constant</span> <span class="n">Const_Int_Ptr</span><span class="p">;</span>  <span class="c1">-- отложенная константа</span>
<span class="kd">private</span>
   <span class="n">The_Variable</span><span class="p">:</span> <span class="kr">aliased</span> <span class="kt">Integer</span><span class="p">;</span>
   <span class="no">The_Ptr</span><span class="p">:</span> <span class="kr">constant</span> <span class="n">Const_Int_Ptr</span> <span class="p">:=</span> <span class="n">The_Variable</span><span class="p">&#39;</span><span class="na">Access</span><span class="p">;</span>
   <span class="p">...</span>
<span class="kr">end</span> <span class="nf">P</span><span class="p">;</span>
</pre></div>
</div>
<p>Клиент может читать значение The_Variable, используя The_Ptr, написав</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="p">:=</span> <span class="n">The_Ptr</span><span class="p">.</span><span class="kr">all</span><span class="p">;</span>  <span class="c1">-- косвенное чтение The_Variable</span>
</pre></div>
</div>
<p>Но, поскольку ссылочный тип описан, как access constant значение объекта
не может быть изменено</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">The_Ptr</span><span class="p">.</span><span class="kr">all</span> <span class="p">:=</span> <span class="n">K</span><span class="p">;</span>  <span class="c1">-- ошибка, так нельзя изменить The_Variable</span>
</pre></div>
</div>
<p>В то же время, любая подпрограмма, объявленная в пакете P, имеет
непосредственный доступ к The_Variable и может изменять ее значение.
Этот способ особенно полезен в случает таблиц, когда таблица вычисляется
динамически, но клиент не должен иметь возможности менять ее.</p>
<p>Используя возможности стандарта Ада 2005, можно избежать введения
ссылочного типа</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">P</span> <span class="kr">is</span>
   <span class="no">The_Ptr</span><span class="p">:</span> <span class="kr">constant</span> <span class="kr">access</span> <span class="kr">constant</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="kd">private</span>
   <span class="n">The_Variable</span><span class="p">:</span> <span class="kr">aliased</span> <span class="kt">Integer</span><span class="p">;</span>
   <span class="no">The_Ptr</span><span class="p">:</span> <span class="kr">constant</span> <span class="kr">access</span> <span class="kr">constant</span> <span class="kt">Integer</span> <span class="p">:=</span>
          <span class="n">The_Variable</span><span class="p">&#39;</span><span class="na">Access</span><span class="p">;</span>
   <span class="p">...</span>
<span class="kr">end</span> <span class="nf">P</span><span class="p">;</span>
</pre></div>
</div>
<p>Ключевое слово constant встречается дважды в объявлении The_Ptr. Первое
означает, что The_Ptr это константа. Второе — что нельзя изменить
объект, на который ссылается The_Ptr.</p>
</section>
<section id="id3">
<h2>Функция-конструктор<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<p>В таких языках, как C++, Java и C# есть специальный синтаксис для
функций, создающих новые объекты. Такие функции называются
конструкторами, их имена совпадают с именем типа. Введение аналогичного
механизма в Аде отклонили, чтобы не усложнять язык. Конструкторы в
других языках имеют дополнительную семантику (например, определяют, как
вызвать конструктор родительского типа, в какой момент вызывать
конструктор относительно инициализации по умолчанию и т.д.). Ада
предлагает несколько конструкций, которые можно использовать вместо
конструкторов, например, использование дискриминантов для параметризации
инициализации, использование контролируемых типов с предоставляемой
пользователем процедурой Initialize (к этому мы вернемся позже),
обыкновенные функции, возвращающие значение целевого типа, поэтому
необходимости в дополнительных средствах нет.</p>
</section>
<section id="id4">
<h2>Лимитируемые типы<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<p>Типы, которые мы встречали до сих пор (Integer, Float, Date, Circle и
др.), имеют различные операции. Некоторые из них предопределены, к ним
относятся сравнение на равенство. Другие, такие как Area у типа Circle,
определены пользователем. Операция присваивания также существует у всех
перечисленных выше типов.</p>
<p>В некоторых случаях иметь операцию присваивания нежелательно. Этому
может быть две главные причины</p>
<ul class="simple">
<li><p>тип может представлять некоторый ресурс, например права доступа,
копирование которого нарушает политику безопасности</p></li>
<li><p>тип может быт реализован с использованием ссылок и копирование
затронет только ссылку, а не все данные.</p></li>
</ul>
<p>Мы можем предотвратить присваивание, объявив тип limited. Для
иллюстрации второй причины рассмотрим стек, реализованный в виде
односвязного списка:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">Linked_Stacks</span> <span class="kr">is</span>
   <span class="kd">type</span> <span class="kt">Stack</span> <span class="kr">is</span> <span class="kr">limited</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">procedure</span> <span class="nf">Clear</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Stack</span><span class="p">);</span>
   <span class="kd">procedure</span> <span class="nf">Push</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">in</span> <span class="nv">Float</span><span class="p">);</span>
   <span class="kd">procedure</span> <span class="nf">Pop</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Float</span><span class="p">);</span>
<span class="kd">private</span>
   <span class="kd">type</span> <span class="kt">Cell</span> <span class="kr">is</span> <span class="kr">record</span>
      <span class="n">Next</span><span class="p">:</span> <span class="kr">access</span> <span class="n">Cell</span><span class="p">;</span>
      <span class="n">Value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">;</span>
   <span class="kr">end record</span><span class="p">;</span>

   <span class="kd">type</span> <span class="kt">Stack</span> <span class="kr">is</span> <span class="kr">access</span> <span class="kr">all</span> <span class="n">Cell</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Linked_Stacks</span><span class="p">;</span>
</pre></div>
</div>
<p>Тело пакета может быть следующим:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="kd">body</span> <span class="nc">Linked_Stacks</span> <span class="kr">is</span>

   <span class="kd">procedure</span> <span class="nf">Clear</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Stack</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">S</span> <span class="p">:=</span> <span class="kc">null</span><span class="p">;</span>
   <span class="kr">end</span> <span class="nf">Clear</span><span class="p">;</span>

   <span class="kd">procedure</span> <span class="nf">Push</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">in</span> <span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">S</span> <span class="p">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">&#39;(</span><span class="n">S</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
   <span class="kr">end</span> <span class="nf">Push</span><span class="p">;</span>

   <span class="kd">procedure</span> <span class="nf">Pop</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">X</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
      <span class="n">S</span> <span class="p">:=</span> <span class="n">Stack</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">Next</span><span class="p">);</span>
   <span class="kr">end</span> <span class="nf">Pop</span><span class="p">;</span>

<span class="kr">end</span> <span class="nf">Linked_Stacks</span><span class="p">;</span>
</pre></div>
</div>
<p>Объявление стека как limited private запрещает операцию присваивания.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">This_One</span><span class="p">,</span> <span class="n">That_One</span><span class="p">:</span> <span class="n">Stack</span><span class="p">;</span>

<span class="n">This_One</span> <span class="p">:=</span> <span class="n">That_One</span><span class="p">;</span>  <span class="c1">-- неверно, тип Stack лимитированный</span>
</pre></div>
</div>
<p>Если бы такое присваивание сработало, это привело бы к тому, что
This_One указывал бы на тот же список, что и That_One. Вызов Pop с
This_One просто сдвинет его по списку That_One вниз. Проблемы такого
характера имеют общепринятое название — алиасинг, т. е. существование
более чем одного способа сослаться на один и тот же объект. Зачастую это
чревато плохими последствиями.</p>
<p>Объявление стека в данном примере работает успешно, благодаря тому, что
он автоматически специализируется значением null, обозначающим пустой
стек. Однако, бывают случаи, когда необходимо создать объект,
инициализировав его конкретным значением (например, если мы объявляем
константу). Мы не можем сделать это обычным способом:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">T</span> <span class="kr">is</span> <span class="kr">limited</span> <span class="p">...</span>

<span class="p">...</span>

<span class="no">X</span><span class="p">:</span> <span class="kr">constant</span> <span class="n">T</span> <span class="p">:=</span> <span class="n">Y</span><span class="p">;</span>  <span class="c1">--  ошибка, нельзя скопировать переменную</span>
</pre></div>
</div>
<p>поскольку это повлечет копирование, что запрещено для лимитируемого
типа.</p>
<p>Можно воспользоваться двумя конструкциями — агрегатами и функциями.
Сначала рассмотрим агрегаты. Пусть наш тип представляет некий ключ,
содержащий дату выпуска и некоторый внутренний код:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Key</span> <span class="kr">is</span> <span class="kr">limited</span> <span class="kr">record</span>
   <span class="n">Issued</span><span class="p">:</span> <span class="n">Date</span><span class="p">;</span>
   <span class="n">Code</span><span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="kr">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>Поскольку тип лимитируемый, ключ нельзя скопировать (сейчас его
содержимое видно, но мы это исправим позже). Но мы можем написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">K</span><span class="p">:</span> <span class="n">Key</span> <span class="p">:=</span> <span class="p">(</span><span class="n">Today</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
</pre></div>
</div>
<p>так как, в этом случае, нет копирования целого ключа, вместо этого
отдельные компоненты получают свои значения. Другими словами K строится
по месту нахождения.</p>
<p>Более реалистично было бы объявить тип приватным. Тогда мы бы не имели
возможности использовать агрегат, поскольку компоненты не были бы
видимы. В этом случае мы бы использовали функцию, как конструктор:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">Key_Stuff</span> <span class="kr">is</span>
   <span class="kd">type</span> <span class="kt">Key</span> <span class="kr">is</span> <span class="kr">limited</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">function</span> <span class="nf">Make_Key</span><span class="p">(...)</span> <span class="kr">return</span> <span class="n">Key</span><span class="p">;</span>
   <span class="p">...</span>
<span class="kd">private</span>
   <span class="kd">type</span> <span class="kt">Key</span> <span class="kr">is</span> <span class="kr">limited</span> <span class="kr">record</span>
      <span class="n">Issued</span><span class="p">:</span> <span class="n">Date</span><span class="p">;</span>
      <span class="n">Code</span><span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
   <span class="kr">end record</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Key_Stuff</span><span class="p">;</span>

<span class="kd">package</span> <span class="kd">body</span> <span class="nc">Key_Stuff</span> <span class="kr">is</span>

   <span class="kd">function</span> <span class="nf">Make_Key</span><span class="p">(...)</span> <span class="kr">return</span> <span class="n">Key</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="kr">return</span> <span class="n">New_Key</span><span class="p">:</span> <span class="n">Key</span> <span class="kr">do</span>
         <span class="n">New_Key</span><span class="p">.</span><span class="n">Issued</span> <span class="p">:=</span> <span class="n">Today</span><span class="p">;</span>
         <span class="n">New_Key</span><span class="p">.</span><span class="n">Code</span> <span class="p">:=</span> <span class="p">...;</span>
      <span class="kr">end</span> <span class="nf">return</span><span class="p">;</span>
   <span class="kr">end</span> <span class="nf">Make_Key</span><span class="p">;</span>
   <span class="p">...</span>
<span class="kr">end</span> <span class="nf">Key_Stuff</span><span class="p">;</span>
</pre></div>
</div>
<p>Клиент теперь может написать</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Key</span><span class="p">:</span> <span class="n">Key</span> <span class="p">:=</span> <span class="n">Make_Key</span> <span class="p">(...);</span>  <span class="c1">-- тут нет копирования</span>
</pre></div>
</div>
<p>где параметры Make_Key используются для вычисления ключа.</p>
<p>Давайте обратим внимание на функцию Make_Key. Она содержит расширенную
инструкцию возврата (return), которая начинается с объявления
возвращаемого объекта New_Key. Когда результирующий тип функции
лимитируемый, возвращаемый объект, на самом деле, строится сразу по
месту своего нахождения (в нашем случае в переменной My_Key). Это
выполняется аналогично тому, как заполняются компоненты при
использовании агрегата. Поэтому копирования не выполняется.</p>
<p>В итоге в Аде мы имеем механизм инициализации клиентских объектов без
использования копирования. Использование лимитируемых типов дает
создателю ресурсов, таких как ключи, мощный механизм контроля их
использования.</p>
</section>
<section id="id5">
<h2>Контролируемые типы<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h2>
<p>Еще более мощным механизмом управлением объектами являются
контролируемые типы. С их помощью можно написать код, исполняемый когда:</p>
<p>1. объект создается; 1. объект прекращает существование; 1. объект
копируется, если он не лимитируемого типа.</p>
<p>В основе этого механизма лежат типы Controlled и Limited_Controlled,
объявленные в пакете Ada.Finalization:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">Ada.Finalization</span> <span class="kr">is</span>

   <span class="kd">type</span> <span class="kt">Controlled</span> <span class="kr">is</span> <span class="kr">abstract</span> <span class="kr">tagged</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">procedure</span> <span class="nf">Initialize</span><span class="p">(</span><span class="nv">Object</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Controlled</span><span class="p">)</span> <span class="kr">is</span> <span class="kc">null</span><span class="p">;</span>
   <span class="kd">procedure</span> <span class="nf">Adjust</span><span class="p">(</span><span class="nv">Object</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Controlled</span><span class="p">)</span> <span class="kr">is</span> <span class="kc">null</span><span class="p">;</span>
   <span class="kd">procedure</span> <span class="nf">Finalize</span><span class="p">(</span><span class="nv">Object</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Controlled</span><span class="p">)</span> <span class="kr">is</span> <span class="kc">null</span><span class="p">;</span>

   <span class="kd">type</span> <span class="kt">Limited_Controlled</span> <span class="kr">is</span> <span class="kr">abstract</span> <span class="kr">tagged</span> <span class="kd">private</span><span class="p">;</span>
   <span class="kd">procedure</span> <span class="nf">Initialize</span><span class="p">(</span><span class="nv">Object</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Limited_Controlled</span><span class="p">)</span>       <span class="kr">is</span> <span class="kc">null</span><span class="p">;</span>
   <span class="kd">procedure</span> <span class="nf">Finalize</span><span class="p">(</span><span class="nv">Object</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Limited_Controlled</span><span class="p">)</span>
      <span class="kr">is</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">private</span>
   <span class="p">...</span>
<span class="kr">end</span> <span class="nf">Ada.Finalization</span><span class="p">;</span>
</pre></div>
</div>
<p>Синтаксис is null введен в Ада 2005 и упрощает определение поведения по
умолчанию.</p>
<p>Основная идея (для нелимитируемых типов) состоит в том, что пользователь
наследует свой тип от Controlled и переопределяет процедуры Initialize,
Adjust и Finalize. Эти процедуры вызываются, когда объект создается,
копируется и уничтожается, соответственно. Отметим, что вызов этих
подпрограмм вставляется автоматически компилятором и программисту не
нужно явно их вызывать. Аналогично обстоит дело с лимитируемыми типами.
Различие в том, что используется Limited_Controlled тип, у которого
отсутствует подпрограмма Adjust, поскольку копирование запрещено. Эти
подпрограммы используются, чтобы реализовать сложную инициализацию,
осуществлять глубокое копирование связных структур данных, освобождение
памяти по окончании жизни объекта и тому подобной деятельности,
специфичной для данного типа.</p>
<p>В качестве примера, снова рассмотрим стек, реализованный в виде связного
списка, но предоставим возможность копирования. Напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">Linked_Stacks</span> <span class="kr">is</span>
   <span class="kd">type</span> <span class="kt">Stack</span> <span class="kr">is</span> <span class="kr">limited</span> <span class="kd">private</span><span class="p">;</span>

   <span class="kd">procedure</span> <span class="nf">Clear</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Stack</span><span class="p">);</span>
   <span class="kd">procedure</span> <span class="nf">Push</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">in</span> <span class="nv">Float</span><span class="p">);</span>
   <span class="kd">procedure</span> <span class="nf">Pop</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Float</span><span class="p">);</span>
<span class="kd">private</span>

   <span class="kd">type</span> <span class="kt">Cell</span> <span class="kr">is</span> <span class="kr">record</span>
      <span class="n">Next</span><span class="p">:</span> <span class="kr">access</span> <span class="n">Cell</span><span class="p">;</span>
      <span class="n">Value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">;</span>
   <span class="kr">end record</span><span class="p">;</span>

   <span class="kd">type</span> <span class="kt">Stack</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Controlled</span> <span class="kr">with</span> <span class="kr">record</span>
      <span class="n">Header</span><span class="p">:</span> <span class="kr">access</span> <span class="n">Cell</span><span class="p">;</span>
   <span class="kr">end record</span><span class="p">;</span>

   <span class="kr">overriding</span> <span class="kd">procedure</span> <span class="nf">Adjust</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">Linked_Stacks</span><span class="p">;</span>
</pre></div>
</div>
<p>Тип Stack теперь приватный. Полное объявление типа - это теговый тип,
порожденный от типа Controlled и имеющий компонент Header, аналогичный
предыдущему объявлению стека. Это просто обертка. Клиент же не видит,
что наш тип теговый и контролируемый. Чтобы присваивание работало
корректно, мы переопределяем процедуру Adjust. Обратите внимание, что мы
используем индикатор overriding, что заставляет компилятор проверить
правильность параметров. Тело пакета может быть следующим:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="kd">body</span> <span class="nc">Linked_Stacks</span> <span class="kr">is</span>

   <span class="kd">procedure</span> <span class="nf">Clear</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Stack</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">S</span> <span class="p">:=</span> <span class="p">(</span><span class="kt">Controlled</span> <span class="kn">with</span> <span class="n">Header</span> <span class="p">=&gt;</span> <span class="kc">null</span><span class="p">);</span>
   <span class="kr">end</span> <span class="nf">Clear</span><span class="p">;</span>

   <span class="kd">procedure</span> <span class="nf">Push</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">in</span> <span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">S</span><span class="p">.</span><span class="n">Header</span> <span class="p">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">&#39;(</span><span class="n">S</span><span class="p">.</span><span class="n">Header</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
   <span class="kr">end</span> <span class="nf">Push</span><span class="p">;</span>

   <span class="kd">procedure</span> <span class="nf">Pop</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">X</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Header</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
      <span class="n">S</span><span class="p">.</span><span class="n">Header</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Header</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
   <span class="kr">end</span> <span class="nf">Pop</span><span class="p">;</span>

   <span class="kd">function</span> <span class="nf">Clone</span><span class="p">(</span><span class="nv">L</span><span class="p">: </span><span class="nv">access</span> <span class="nv">Cell</span><span class="p">)</span> <span class="kr">return</span> <span class="kr">access</span> <span class="n">Cell</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="kr">if</span> <span class="n">L</span> <span class="o">=</span> <span class="kc">null</span> <span class="kr">then</span>
         <span class="kr">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kr">else</span>
         <span class="kr">return</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">&#39;(</span><span class="n">Clone</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">Next</span><span class="p">),</span> <span class="n">L</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
      <span class="kr">end</span> <span class="kr">if</span><span class="p">;</span>
   <span class="kr">end</span> <span class="nf">Clone</span><span class="p">;</span>

   <span class="kd">procedure</span> <span class="nf">Adjust</span> <span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="n">S</span><span class="p">.</span><span class="n">Header</span> <span class="p">:=</span> <span class="n">Clone</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">Header</span><span class="p">);</span>
   <span class="kr">end</span> <span class="nf">Adjust</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Linked_Stacks</span><span class="p">;</span>
</pre></div>
</div>
<p>Теперь присваивание будет работать как надо. Допустим, мы напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">This_One</span><span class="p">,</span> <span class="n">That_One</span><span class="p">:</span> <span class="n">Stack</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">This_One</span> <span class="p">:=</span> <span class="n">That_One</span><span class="p">;</span>  <span class="c1">--  автоматический вызов Adjust</span>
</pre></div>
</div>
<p>Сперва выполняется побитовое копирование That_One в This_One, затем для
This_One выполняется вызов Adjust, где вызывается рекурсивная функция
Clone, которая и выполняет фактическое копирование. Часто такой процесс
называют глубоким копированием. В результате This_One и That_One
содержат одинаковые элементы, но их внутренние структуры никак не
пересекаются.</p>
<p>Интересным моментом, также, может быть то, как в процедуре Clear
устанавливается параметр S. Эта конструкция называется расширенным
агрегатом. Первая часть агрегата — имя родительского типа, а часть после
слова with предоставляет значения дополнительным компонентам, если такие
имеются. Процедуры Push и Pop — тривиальны.</p>
<p>Читатель может спросить, что произойдет с занимаемой памятью после
вызова процедуры Pop или Clear. Мы обсудим это в следующей главе,
касающейся вопросов управления памятью.</p>
<p>Следует отметить, что процедуры Initialize и Finalize не переопределены
и наследуются пустые процедуры от типа Controlled. Поэтому ничего
дополнительного не выполняется в момент объявления стека. Это нам
подходит, потому что компонента Header получает значение null по
умолчанию, что нам и требуется. Аналогично, никаких действий не
происходит, когда стек уничтожается, например при выходе из процедуры.
Тут снова встает вопрос об освобождении памяти, к которому мы вернемся в
следующей главе.</p>
</section>
</section>


           </div>
          </div>
          


<footer>
      
      

      
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
          
            <a href="chapter_07.html" class="btn btn-neutral float-right" title="Безопасное управление памятью" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
          
          
            <a href="chapter_05.html" class="btn btn-neutral" title="Безопасное объектно-ориентированное программирование" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
          
        </div>
  


  <hr/>

  <div class="legal">
              Copyright &copy; 2022 AdaCore. All rights reserved.
              &nbsp;&nbsp;
              <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
              <br>
              <a href="https://www.adacore.com/company/legal">Legal</a>
              &nbsp; |  &nbsp;
              <a href="https://www.adacore.com/company/privacy">Privacy Policy</a>
              &nbsp; |  &nbsp;
              <a href="https://github.com/AdaCore/learn/issues">Report an Issue</a>
            </div> 

</footer>

        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>
  <button id="scrollToTopBtn" title="Go to top"><i class="fas fa-caret-square-up"></i></button>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
</script>


</body>
</html>
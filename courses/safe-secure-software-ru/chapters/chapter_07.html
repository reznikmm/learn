<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Безопасное управление памятью &mdash; learn.adacore.com</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/style.6b9ffa6b650d4d2b2239.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/1.style.6b9ffa6b650d4d2b2239.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/main.6b9ffa6b650d4d2b2239.js"></script>
        <script src="../../../_static/1.main.6b9ffa6b650d4d2b2239.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Безопасный запуск" href="chapter_08.html" />
    <link rel="prev" title="Безопасное создание объектов" href="chapter_06.html" />
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-117428-14"></script>
<script type="text/javascript">
  if(!Cookies.get('AdaCore_staff')) {
    // Global site tag (gtag.js) - Google Analytics
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-117428-14');
    // End Global site tag (gtag.js) - Google Analytics

    // Google Tag Manager
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KD5HNRR');
    // End Google Tag Manager

    // Twitter universal website tag code
    !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
    // Insert Twitter Pixel ID and Standard Event data below
    twq('init','o3mlc');
    twq('track','PageView');
    // End Twitter universal website tag code

    // LinkedIn Tracking Tags
    _linkedin_partner_id = "482585"; window._linkedin_data_partner_ids = window._linkedin_data_partner_ids || []; window._linkedin_data_partner_ids.push(_linkedin_partner_id);
    (function(){var s = document.getElementsByTagName("script")[0]; var b = document.createElement("script"); b.type = "text/javascript";b.async = true; b.src = "https://snap.licdn.com/li.lms-analytics/insight.min.js"; s.parentNode.insertBefore(b, s);})();
    // End LinkedIn Tracking Tags
  }
</script>
  <!--  Essential META Tags -->
<meta property="og:title" content=“learn.adacore.com">
<meta property="og:description" content="An interactive learning platform to teach the Ada and SPARK programming languages.">
<meta property="og:image" content="https://learn.adacore.com/_static/learn_meta_img.jpeg">
<meta property="og:url" content="https://learn.adacore.com">
<meta name="twitter:card" content="summary_large_image">

<!--  Non-Essential, But Recommended -->
<meta property="og:site_name" content="learn.adacore.com">
<meta name="twitter:image:alt" content="An interactive learning platform to teach the Ada and SPARK programming languages.">

<!--  Non-Essential, But Required for Analytics -->
<meta name="twitter:site" content="@AdaCoreCompany">

</head>

<body class="wy-body-for-nav">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KD5HNRR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <!-- LinkedIn Tracking Tags (noscript) -->
  <noscript> <img height="1" width="1" style="display:none;" alt="" src="https://dc.ads.linkedin.com/collect/?pid=482585&fmt=gif" /> </noscript>
  <!-- End LinkedIn Tracking Tags (noscript) -->

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">Подробнее</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Курсы</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../intro-to-ada-ru/index.html">Введение в язык Ада</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html">Введение</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id2">История</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id3">Ада сегодня</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id7">Философия</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#spark">SPARK</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html">Императивы языка</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#hello-world">Hello world</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id2">Условный оператор</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id3">Циклы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#for">Циклы for</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id4">Простой цикл</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#while">Циклы while</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id5">Оператор выбора</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id6">Зоны описания</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id7">Условные выражения</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id8">Условное выражение</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id9">Выражение выбора</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html">Подпрограммы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id2">Подпрограммы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id3">Вызовы подпрограмм</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id4">Вложенные подпрограммы</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id5">Вызов функций</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id6">Виды параметров</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id7">Вызов процедуры</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#in">Параметры in</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#in-out">Параметры in out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#out">Параметры out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id8">Предварительное объявление подпрограмм</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#intro-ada-ru-subprogram-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html">Модульное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id2">Пакеты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-use-clause">Использование пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id4">Тело пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-childpackages">Дочерние пакеты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id6">Дочерний пакет от дочернего пакета</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id7">Множественные потомки</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id8">Видимость</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-package-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html">Сильно типизированный язык</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-whatisatype">Что такое тип?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#integers">Целочисленные типы - Integers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id3">Семантика операций</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id4">Беззнаковые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-enumtypes">Перечисления</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id7">Типы с плавающей запятой</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id8">Основные свойства</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id9">Точность типов с плавающей запятой</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id10">Диапазон значений для типов с плавающей запятой</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id11">Строгая типизация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id12">Производные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id13">Подтипы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-subtypealiases">Подтипы в качестве псевдонимов типов</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html">Записи</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#intro-ada-ru-record-type-declaration">Объявление типа записи</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#id3">Агрегаты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#id4">Извлечение компонент</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#record-comp-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html">Массивы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id2">Объявление типа массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id3">Доступ по индексу</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id4">Более простые объявления массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id5">Атрибут диапазона</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#intro-ada-ru-unconstrainedarraytypes">Неограниченные массивы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#string">Предопределенный тип String</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id7">Ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id8">Возврат неограниченных массивов</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id9">Объявление массивов (2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id10">Отрезки массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#intro-ada-ru-object-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html">Подробнее о типах</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#id2">Агрегаты: краткая информация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#c">Cовмещение и квалифицированные выражения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#id4">Символьные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html">Ссылочные типы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id2">Введение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#allocation">Выделение (allocation) памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#intro-ada-ru-access-dereferencing">Извлечение по ссылке</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id4">Другие особенности</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id5">Взаимно рекурсивные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html">Подробнее о записях</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#id2">Типы записей динамически изменяемого размера</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#id3">Записи с дискриминантом</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#c">Записи c вариантами</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html">Типы с фиксированной запятой</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html#id2">Десятичные типы с фиксированной запятой</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html#id3">Обычные типы с фиксированной запятой</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html">Изоляция</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id3">Простейшая инкапсуляция</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id4">Абстрактные типы данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id5">Лимитируемые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id7">Дочерние пакеты и изоляция</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html">Настраиваемые модули</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id2">Введение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id3">Объявление формального типа</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id4">Объявление формального объекта</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id5">Определение тела настраиваемого модуля</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id6">Конкретизация настройки</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id7">Настраиваемые пакеты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id8">Формальные подпрограммы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id9">Пример: конкретизация ввода/вывода</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id10">Пример: АТД</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id11">Пример: Обмен</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id12">Пример: Обратный порядок элементов</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id13">Пример: Тестовое приложение</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html">Исключения</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id2">Объявление исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id3">Возбуждение исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id4">Обработка исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id5">Предопределенные исключения</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html">Управление задачами</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id2">Задачи</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id5">Простая задача</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id6">Простая синхронизация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id7">Оператор задержки</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id8">Синхронизация: рандеву</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id9">Обрабатывающий цикл</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id10">Циклические задачи</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id11">Защищенные объекты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id12">Простой объект</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id13">Входы</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id14">Задачные и защищенные типы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#intro-ada-ru-tasktypes">Задачные типы</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id16">Защищенные типы</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html">Контрактное проектирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id2">Пред- и постусловия</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id3">Предикаты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id4">Инварианты типа</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html">Взаимодействие с языком C</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id1">Многоязычный проект</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id2">Соглашение о типах</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id3">Подпрограммы на других языках</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id4">Вызов подпрограмм C из Ады</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id5">Вызов Ада подпрограмм из C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id6">Внешние переменные</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id7">Использование глобальных переменных C в Аде</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id8">Использование переменных Ада в C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id9">Автоматическое создание связок</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id10">Адаптация связок</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html">Объектно-ориентированное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id2">Производные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id3">Теговые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id5">Надклассовые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id6">Операции диспетчеризации</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id7">Точечная нотация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id8">Личные и лимитируемые типы с тегами</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id9">Надклассовые ссылочные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html">Стандартная библиотека: Контейнеры</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id2">Векторы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id3">Создание экземпляра</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id4">Инициализация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id5">Добавление элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id6">Доступ к первому и последнему элементам</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id7">Итерация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id8">Поиск и изменение элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id9">Вставка элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id10">Удаление элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id11">Другие операции</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id12">Множества</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id13">Инициализация и итерация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id14">Операции с элементами</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id15">Другие операции</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id16">Отображения для неопределенных типов</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id17">Хэшированные отображения</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id18">Упорядоченные отображения</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id19">Сложность</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html">Стандартная библиотека: Дата и время</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#intro-ada-ru-datestimes">Обработка даты и времени</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id3">Задержка с использованием даты</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id4">Режим реального времени</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id5">Анализ производительности</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html">Стандартная библиотека: Строки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id2">Операции со строками</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id3">Ограничение строк фиксированной длины</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id4">Ограниченные строки</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#intro-ada-ru-unboundedstrings">Неограниченные строки</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html">Стандартная библиотека: Файлы и потоки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id2">Текстовый ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id3">Последовательный ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id4">Прямой ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id5">Потоковый ввод-вывод</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html">Стандартная библиотека: Numerics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id1">Элементарные функции</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id2">Генерация случайных чисел</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id3">Комплексные числа</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id4">Работа с векторами и матрицами</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html">Приложения</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#a">Приложение A: Формальные типы настройки</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#id2">Неопределенные версии типов</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#b">Приложение B: Контейнеры</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Безопасное и надежное программное обеспечение</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Вступление</a></li>
<li class="toctree-l2"><a class="reference internal" href="foreword.html">Предисловие</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_01.html">Безопасный синтаксис</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id2">Присваивание и проверка на равенство</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id3">Группы инструкций</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id4">Именованное сопоставление</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id5">Целочисленные литералы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_02.html">Безопасные типы данных</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id2">Использование индивидуальных типов</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id3">Перечисления и целые</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id4">Ограничения и подтипы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id5">Предикаты подтипов</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id6">Массивы и ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id7">Установка начальных значений по умолчанию</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_02.html#id8">«Вещественные ошибки»</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_03.html">Безопасные указатели</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id2">Ссылки, указатели и адреса</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id3">Ссылочные типы и строгая типизация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id4">Ссылочные типы и контроль доступности</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id5">Ссылки на подпрограммы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id6">Вложенные подпрограммы в качестве параметров</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_04.html">Безопасная архитектура</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id2">Спецификация и тело пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id3">Приватные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id4">Контрактная модель настраиваемых модулей</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id5">Дочерние модули</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id6">Модульное тестирование</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id7">Взаимозависимые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id8">Контрактное программирование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_05.html">Безопасное объектно‐ориентированное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id2">ООП вместо структурного программирования</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#overriding">Индикатор overriding</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id3">Запрет диспетчеризации вызова подпрограмм</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id4">Интерфейсы и множественное наследование</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id5">Взаимозаменяемость</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_06.html">Безопасное создание объектов</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id2">Переменные и константы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id3">Функция-конструктор</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id4">Лимитируемые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id5">Контролируемые типы</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Безопасное управление памятью</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Переполнение буфера</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Динамическое распределение памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Пулы памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Ограничения</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_08.html">Безопасный запуск</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id2">Предвыполнение</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id3">Директивы компилятору, связанные с предвыполнением</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id4">Динамическая загрузка</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_09.html">Безопасная коммуникация</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id2">Представление данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id3">Корректность данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id4">Взаимодействие с другими языками</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id5">Потоки ввода/вывода</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id6">Фабрики объектов</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_10.html">Безопасный параллелизм</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id2">Операционные системы и задачи</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id3">Защищенные объекты</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id4">Рандеву</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id5">Ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#ravenscar">Ravenscar</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id6">Безопасное завершение</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id7">Время и планирование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_11.html">Сертификация с помощью SPARK</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id1">Контракты</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id2">SPARK — подмножество языка Ада</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id3">Формальные методы анализа</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id4">Гибридная верификация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id5">Примеры</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id6">Сертификация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id7">Дальнейший процесс</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html">Заключение</a></li>
<li class="toctree-l2"><a class="reference internal" href="biblio.html">Список литературы</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
  <i data-toggle="wy-nav-top" class="fas fa-bars"></i>
    <a href="../../../index.html">
    <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
  </a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>Безопасное управление памятью<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>Компьютерная память, используемая программой, является критически важным
ресурсом системы. Целостность его содержимого является необходимым
условием здорового функционирования программы. Тут можно проследить
аналогию с памятью человека. Когда память ненадежна, жизнь человека
заметно ухудшается.</p>
<p>Есть две проблемы, которые связаны с вопросом управления памятью. Первая
заключается в том, что информация может быть потеряна в случае, если она
ошибочно перетирается другой информацией. Другая проблема в том, что
память может быть утеряна после использования и, в конце концов, вся
свободная память будет исчерпана, что приведет к невозможности сохранить
нужную информацию. Эта проблема утечки памяти.</p>
<p>Утечка памяти является коварной проблемой, поскольку может не
проявляться длительное время. Известны примеры из области управления
химическим производством, когда казалось, что программа работала в
течении нескольких лет. Ее перезапускали каждые три месяца по
независимым причинам (перемещали кран, что приводило к остановке
производства). Когда график перемещения крана изменился, программа
должна была работать дольше, но в итоге сломалась после четырех месяцев
непрерывной работы. Причина оказалась в утечке памяти, понемногу
отгрызающей свободное пространство.</p>
<section id="id2">
<h2>Переполнение буфера<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>Переполнение буфера - это общее название, используемое для обозначения
нарушения информационной безопасности. Переполнение буфера может
привести к искажению или чтению информации злоумышленником, либо
случайно.</p>
<p>Эта проблема широко распространена в программах на C и C++ и зачастую
связана с отсутствием проверок выхода за пределы массивов в этих языках.
Мы встречались с подобной проблемой в главе «Безопасные типы данных» в
примере с парой игральных костей.</p>
<p>Эта проблема не может возникнуть в Аде, поскольку в обычных условиях
проверка индекса при обращении к массиву активирована. Эту проверку
можно отключить, когда мы абсолютно уверены в поведении программы, но
это может быть неблагоразумно, пока мы не доказали корректность
программы формальным методом, например, используя инструментарий SPARK
Examiner, который мы обсудим в главе 11.</p>
<p>Хотя, в подавляющем количестве случаев виновником переполнения буфера
является отсутствие проверки индекса массива, другие свойства языка
также могут его вызвать. Например, обозначение конца строки с помощью
нулевого байта. Это приводит ко множеству мест в программе, где
программист должен проверить этот маркер. Легко ошибиться, выписывая эти
тесты так, чтобы они работали верно в любой ситуации. В результате это
приводит к появлению узких мест, которые используются вирусами для
проникновения в систему.</p>
<p>Другой распространенной причиной разрушения данных является
использование некорректных значений указателей. Указатели в C трактуются
как адреса и для них разрешены арифметические операции. Как следствие,
легко может возникнуть ситуация, когда значение указателя вычислено
неверно. Запись по этому указателю разрушит какие-то данные.</p>
<p>В главе «Безопасные указатели» мы видели, что строгая типизация
указателей и правила контроля доступности в Аде защищают нас от подобных
ошибок, гарантируя, что объявленный объект не исчезнет, пока на него
ссылаются другие объекты.</p>
<p>Таким образом фундаментальные свойства языка Ада защищают от случайной
потери данных, связанной с разрушением содержимого памяти. Остаток этой
главы мы посвятим проблеме утечки памяти.</p>
</section>
<section id="id3">
<h2>Динамическое распределение памяти<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<p>Обычно языки программирования предоставляют три способа распределения
памяти:</p>
<ul class="simple">
<li><p>глобальные данные существуют в течении всего времени работы
программы, поэтому могут иметь постоянное положение в памяти и обычно
распределяются статически;</p></li>
<li><p>данные ,сохраненные в стеке, распределяются и освобождаются синхронно
с вызовом подпрограмм;</p></li>
<li><p>данные, распределенные динамически, время жизни которых не связанно с
временем работы подпрограмм.</p></li>
</ul>
<p>Секция common в Fortran — исторический пример глобального статического
распределения, но подобные механизмы есть и в других языках. В Аде мы
можем объявить:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">package</span> <span class="nc">Calandar_Data</span> <span class="kr">is</span>

   <span class="kd">type</span> <span class="kt">Month</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Jan</span><span class="p">,</span> <span class="nv">Feb</span><span class="p">,</span> <span class="nv">Mar</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">Nov</span><span class="p">,</span> <span class="nv">Dec</span><span class="p">);</span>

   <span class="n">Days_In_Month</span><span class="p">:</span> <span class="kr">array</span> <span class="p">(</span><span class="n">Month</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">Integer</span> <span class="p">:=</span>
      <span class="p">(</span><span class="n">Jan</span> <span class="p">=&gt;</span> <span class="mi">31</span><span class="p">,</span> <span class="n">Feb</span> <span class="p">=&gt;</span> <span class="mi">28</span><span class="p">,</span> <span class="n">Mar</span> <span class="p">=&gt;</span> <span class="mi">31</span><span class="p">,</span> <span class="n">Apr</span> <span class="p">=&gt;</span> <span class="mi">30</span><span class="p">,</span>
       <span class="n">May</span> <span class="p">=&gt;</span> <span class="mi">31</span><span class="p">,</span> <span class="n">Jun</span> <span class="p">=&gt;</span> <span class="mi">30</span><span class="p">,</span> <span class="n">Jul</span> <span class="p">=&gt;</span> <span class="mi">31</span><span class="p">,</span> <span class="n">Aug</span> <span class="p">=&gt;</span> <span class="mi">31</span><span class="p">,</span>
       <span class="n">Sep</span> <span class="p">=&gt;</span> <span class="mi">30</span><span class="p">,</span> <span class="n">Oct</span> <span class="p">=&gt;</span> <span class="mi">31</span><span class="p">,</span> <span class="n">Nov</span> <span class="p">=&gt;</span> <span class="mi">30</span><span class="p">,</span> <span class="n">Dec</span> <span class="p">=&gt;</span><span class="mi">31</span><span class="p">);</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Память, выделяемая под Days_In_Month, будет, естественно, выделена в
фиксированной глобальной области.</p>
<p>Стек - важный механизм распределения памяти во всех современных языках
программирования. Отметим, что речь тут идет о механизме, связанном с
реализацией распределения памяти, а не об объектах типа Stack из
предыдущих глав. Стек используется для передачи параметров при вызове
подпрограмм (в том числе передачи аргументов, хранения адреса возврата,
сохранения промежуточных регистров, и т. д.), а также локальных
переменных подпрограммы. В многозадачной программе, где несколько
потоков управления исполняются параллельно, каждая задача имеет свой
стек.</p>
<p>Вернемся к функции Nfv_2000 из примера вычисления процентных ставок:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Nfv_2000</span> <span class="p">(</span><span class="nv">X</span><span class="p">: </span><span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="no">Factor</span><span class="p">:</span> <span class="kr">constant</span> <span class="kt">Float</span> <span class="p">:=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">X</span><span class="o">/</span><span class="mf">100.0</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="kr">return</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">Factor</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">500.0</span> <span class="o">*</span> <span class="n">Factor</span> <span class="o">-</span> <span class="mf">2000.00</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Nfv_2000</span><span class="p">;</span>
</pre></div>
</div>
<p>Объект Factor обычно распределяется в стеке. Он создается при вызове
функции и уничтожается при возврате. Все управление памятью происходит
автоматически, благодаря механизму вызова/возврата подпрограмм. Отметим,
что, хотя Factor является константой, он не является статическим
объектом, потому что каждый вызов функции вычисляет для него свое
значение. Так как две задачи могут вызвать эту функцию одновременно,
Factor нельзя распределить статически. Аналогично, параметр X также
распределяется в стеке.</p>
<p>Теперь рассмотрим более сложный случай, когда подпрограмма объявляет
локальный массив, чей размер неизвестен до момента исполнения. Например
это может быть функция, возвращающая массив в обратном порядке:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">Rev</span> <span class="p">(</span><span class="nv">A</span><span class="p">: </span><span class="nv">Vector</span><span class="p">)</span> <span class="kr">return</span> <span class="n">Vector</span> <span class="kr">is</span>
   <span class="n">Result</span><span class="p">:</span> <span class="n">Vector</span><span class="p">(</span><span class="n">A</span><span class="p">&#39;</span><span class="na">Range</span><span class="p">);</span>
<span class="kr">begin</span>
   <span class="kr">for</span> <span class="n">K</span> <span class="ow">in</span> <span class="n">A</span><span class="p">&#39;</span><span class="na">Range</span> <span class="kr">loop</span>
      <span class="n">Result</span> <span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">:=</span> <span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="p">&#39;</span><span class="na">First</span><span class="o">+</span><span class="n">A</span><span class="p">&#39;</span><span class="na">Last</span><span class="o">-</span><span class="n">K</span><span class="p">);</span>
   <span class="kr">end</span> <span class="kr">loop</span><span class="p">;</span>
   <span class="kr">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Rev</span><span class="p">;</span>
</pre></div>
</div>
<p>где Vector объявлен, как неограниченный массив:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Vector</span> <span class="kr">is</span> <span class="kr">array</span> <span class="p">(</span><span class="kt">Natural</span> <span class="kr">range</span> <span class="p">&lt;&gt;)</span> <span class="kr">of</span> <span class="kt">Float</span><span class="p">;</span>
</pre></div>
</div>
<p>Как объясняется в разделе «Массивы и ограничения» главы «Безопасные типы
данных», эта запись означает, что Vector - это массив, но границы у
разных объектов этого типа могут быть разные. Когда мы объявляем объект
этого типа, мы должны предоставить границы. У нас может быть:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">L</span><span class="p">:</span> <span class="kt">Integer</span> <span class="p">:=</span> <span class="p">...;</span>    <span class="c1">-- L может не быть статическим значением</span>

<span class="n">My_Vector</span><span class="p">,</span> <span class="n">Your_Vector</span><span class="p">:</span> <span class="n">Vector</span> <span class="p">(</span><span class="mi">1</span> <span class="p">..</span> <span class="n">L</span><span class="p">);</span>

<span class="p">...</span>

<span class="n">Your_Vector</span> <span class="p">:=</span> <span class="n">Rev</span> <span class="p">(</span><span class="n">My_Vector</span><span class="p">);</span>
</pre></div>
</div>
<p>В большинстве языков программирования нам бы пришлось распределить
память для такого объекта динамически, поскольку размер объекта не
известен заранее. На самом деле, это не является необходимым, поскольку
стек может расти динамически, а память для локальных объектов всегда
распределяется по принципу последний-зашел-первый-вышел. Такого рода
требования возникают для простоты реализации языка. Приложив некоторые
усилия во время дизайна и реализации языка, можно распределять такого
рода объекты в стеке, сохранив при этом эффективность механизма вызова
подпрограмм.</p>
<p>Хотя такое поведение не требуется согласно стандарту, все промышленные
компиляторы всегда используют стек для хранения локальных данных.
Эффективной техникой в этом случае является использование двух стеков,
один для хранения адресов возврата и локальных данных фиксированного
размера, а другой для данных переменного размера. Это позволит
обрабатывать данные фиксированного размера столь же эффективно, но
сохранит требуемую гибкость в распределении памяти. Кроме того, в Аде
часто применяется контроль за исчерпанием стека. В этом случает при
попытке превысить отведенный размер стека будет возбуждаться исключение
Storage_Error.</p>
<p>Данный пример красиво реализуется в Аде. Реализация на C контрастирует
своей сложностью ввиду того, что в C нет соответствующей абстракции
массивов. Мы можем передать массив, как аргумент, но только при помощи
указателя на массив. Кроме того, в C нельзя вернуть массив, как объект.
Хотя мы можем определить функцию, которая переставляет элементы прямо в
массиве, и требовать от пользователя создавать копию перед ее вызовом.
При этом нужно быть осторожным, чтобы не испортить данные при
перестановке. Проще будет разрешить пользователю передавать как
указатель на аргумент, так и указатель на результат. Следующее
затруднение состоит в том, что в C мы не можем определить размер
массива. Нам придется размер передавать явно. Мы получаем еще один шанс
допустить ошибку, передав значение, не соответствующее длине массива. В
итоге мы получим</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">rev</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="n">k</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="kt">float</span><span class="w"> </span><span class="n">my_vector</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span><span class="w"> </span><span class="n">your_vector</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="n">rev</span><span class="p">(</span><span class="n">my_vector</span><span class="p">,</span><span class="w"> </span><span class="n">your_vector</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Хотя эта глава посвящена управлению памятью, наверное стоит
остановиться, чтобы перечислить риски и затруднения в этом коде на C.</p>
<ul class="simple">
<li><p>Массивы в C всегда индексируются, начиная с 0. Если прикладная
область использует другую нумерацию, например с 1, может возникнуть
путаница. В Аде нижняя граница присутствует всегда в явном виде.</p></li>
<li><p>Длина массива должна передаваться отдельно, что создает риск получить
неверную длину, либо перепутать длину и верхнюю границу массива. В
Аде атрибуты массива неотделимы от массива.</p></li>
<li><p>Адрес результата необходимо передавать отдельно. Появляется
возможность перепутать два массива.</p></li>
<li><p>Цикл для итерации по массиву нужно записывать явно, в то время как в
Аде можно воспользоваться атрибутом 'Range.</p></li>
</ul>
<p>Но мы отклонились от темы. Ключевой момент в том, что, если бы мы
объявили локальный массив в C++, чей размер не задан статически:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[]</span><span class="o">=</span><span class="n">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>то память под такой массив распределялась бы динамически, а не в стеке.
В C пришлось бы использовать функцию malloc.</p>
<p>Основная опасность при динамическом распределении памяти в том, что она
может быть потеряна после использования. Поскольку в языке Ада возможно
создавать объекты произвольного размера в стеке, необходимость
динамического распределения памяти значительно снижается, что повышает
производительность и уменьшает риск утечки памяти.</p>
</section>
<section id="id4">
<h2>Пулы памяти<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<p>Давайте рассмотрим динамическое распределение памяти. Для этого в Аде
используются пулы памяти. Если мы создаем объект динамически, как
например в процедуре Push из главы «Безопасное создание объектов»:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Push</span><span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">in</span> <span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
<span class="kr">begin</span>
   <span class="n">S</span> <span class="p">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">&#39;(</span><span class="n">S</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">Push</span><span class="p">;</span>
</pre></div>
</div>
<p>то память под новый Cell распределяется из пула памяти. Всегда
существует стандартный пул памяти, но мы можем объявить и управлять
своими собственными пулами памяти.</p>
<p>Первым языком программирования, избавившим программиста от необходимости
управлением памятью, был LISP, благодаря использованию механизма сборки
мусора. Этот механизм используется и в других языках, в том числе в Java
и Python. Наличие сборщика мусора значительно упрощает программирование,
но имеет свои проблемы. Например, сборщик мусора может приостанавливать
исполнение программы непредсказуемым образом, что может привести к
проблемам в системах реального времени. Программируя системы реального
времени, необходимо тщательно контролировать распределение памяти, а
также гарантировать время отклика программы, что может быть
затруднительно при использовании сборщика мусора. Одной из причин, по
которой в первый стандарт языка Ада 83 не включали средства ООП, было
то, что автор языка, Жан Ишбиа, занимавшийся в свое время реализацией
ООП языка Simula, был уверен в том, что ООП необходимо иметь сборщик
мусора, а это неприемлемо для систем реального времени. Как впоследствии
было продемонстрировано в C++ и Ада 95, язык может поддерживать ООП без
сборщика мусора, если он предоставляет программисту развитые механизмы
управления памятью.</p>
<p>Ада позволяет программисту выбрать один из следующих механизмов
управления памятью:</p>
<ul class="simple">
<li><p>ручной режим. В этом случае программист освобождает память каждого
объекта индивидуально.</p></li>
<li><p>пул памяти. Объекты можно удалять, как каждый отдельно, так и весь
пул целиком.</p></li>
<li><p>сборщик мусора. Этот режим может быть реализован не во всех системах.</p></li>
</ul>
<p>Чтобы удалить память, занимаемую некоторым объектом, нужно настроить
предопределенную процедуру Unchecked_Deallocation. Для этого нужно
предоставить именованный ссылочный тип. Вспомним тип Cell:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Cell</span><span class="p">;</span>

<span class="kd">type</span> <span class="kt">Cell_Ptr</span> <span class="kr">is</span> <span class="kr">access</span> <span class="kr">all</span> <span class="n">Cell</span><span class="p">;</span>

<span class="kd">type</span> <span class="kt">Cell</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">Next</span><span class="p">:</span> <span class="n">Cell_Ptr</span><span class="p">;</span>
   <span class="n">Value</span><span class="p">:</span> <span class="kt">Float</span><span class="p">;</span>
<span class="kr">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>Обратите внимание, как здесь использовано неполное объявление типа,
чтобы разорвать циклическую зависимость между типами. Теперь напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Free</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Unchecked_Deallocation</span> <span class="p">(</span><span class="n">Cell</span><span class="p">,</span> <span class="n">Cell_Ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>Чтобы удалить память, занимаемую объектом Cell, нужно вызвать процедуру
Free и передать ей ссылку на удаляемый объект. Например, процедура Pop
должна выглядеть так:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Pop</span> <span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">;</span> <span class="nv">X</span><span class="p">: </span><span class="nv">out</span> <span class="nv">Float</span><span class="p">)</span> <span class="kr">is</span>
   <span class="n">Old_S</span> <span class="p">:</span> <span class="n">Stack</span> <span class="p">:=</span> <span class="n">S</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">X</span> <span class="p">:=</span> <span class="n">X</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
   <span class="n">S</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Next</span><span class="p">;</span>
   <span class="n">Free</span> <span class="p">(</span><span class="n">Old_S</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">Pop</span><span class="p">;</span>
</pre></div>
</div>
<p>Здесь мы используем Stack из примера с limited private, а не
контролируемый тип.</p>
<p>Может показаться, что мы рискуем появлением висящих ссылок, поскольку
могут быть другие ссылки, указывающие на удаленный объект. Но, в этом
примере, с точки зрения пользователя, тип Stack лимитированный,
следовательно ,пользователь не может сделать копию. Кроме того,
пользователь не видит типов Cell и Cell_Ptr, поэтому не сможет вызвать
Free. Это нам гарантирует корректность Pop. И, наконец, при настройке
Unchecked_Deallocation используется тип Cell_Ptr, что позволяет
проверить тип аргумента при вызове Free.</p>
<p>Нам необходимо изменить и процедуру Clear. Простейший вариант такой:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Clear</span> <span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">)</span> <span class="kr">is</span>
   <span class="n">Junk</span><span class="p">:</span> <span class="kt">Float</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="kr">while</span> <span class="n">S</span> <span class="o">/=</span> <span class="kc">null</span> <span class="kr">loop</span>
      <span class="n">Pop</span> <span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Junk</span><span class="p">);</span>
   <span class="kr">end</span> <span class="kr">loop</span><span class="p">;</span>
<span class="kr">end</span> <span class="nf">Clear</span><span class="p">;</span>
</pre></div>
</div>
<p>Хотя эта техника позволяет гарантировать, что память очищается при
вызове Pop и Clear, существует риск, что пользователь объявит стек и
выйдет из его области видимости пока стек не пуст. Например</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">procedure</span> <span class="nf">Do_Something</span> <span class="kr">is</span>
   <span class="n">A_Stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="p">...</span> <span class="c1">-- Используем стек</span>
   <span class="p">...</span> <span class="c1">-- Пуст ли стек при выходе?</span>
<span class="kr">end</span> <span class="nf">Do_Something</span><span class="p">;</span>
</pre></div>
</div>
<p>Если стек не был пуст при выходе, то память будет потеряна. Мы не можем
обременять пользователя заботой о таких деталях, поэтому мы должны
сделать тип контролируемым, как было продемонстрировано в конце главы
«Безопасное создание объектов». Мы переопределим процедуру Finalize так:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">overriding</span> <span class="kd">procedure</span> <span class="nf">Finalize</span> <span class="p">(</span><span class="nv">S</span><span class="p">: </span><span class="nv">in</span> <span class="nv">out</span> <span class="nv">Stack</span><span class="p">)</span> <span class="kr">is</span>
<span class="kr">begin</span>
   <span class="n">Clear</span> <span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">Finalize</span><span class="p">;</span>
</pre></div>
</div>
<p>Использовав индикатор overriding, мы заставляем компилятор проверить,
что мы не ошиблись в написании Finalize или в формальных параметрах.</p>
<p>В Аде также есть возможность объявить свои пулы памяти. Это просто, но
потребует слишком много места для описания всех подробностей здесь.
Основная идея в том, что есть тип Root_Storage_Pool (это лимитированный
контролируемый тип) и мы объявляем свой тип, наследуя от него</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">My_Pool_Type</span> <span class="p">(</span><span class="nv">Size</span><span class="p">: </span><span class="nv">Storage_Count</span><span class="p">)</span> <span class="kr">is</span>
  <span class="kr">new</span> <span class="n">Root_Storage_Pool</span> <span class="kr">with</span> <span class="kd">private</span><span class="p">;</span>

<span class="kr">overriding</span> <span class="kd">procedure</span> <span class="nf">Allocate</span><span class="p">(...);</span>

<span class="kr">overriding</span> <span class="kd">procedure</span> <span class="nf">Deallocate</span><span class="p">(...);</span>

<span class="c1">-- также переопределим Initialize и Finalize</span>
</pre></div>
</div>
<p>Процедура Allocate автоматически вызывается, когда создается новый
объект при помощи new, а Deallocate — при вызове настройки
Unchecked_Deallocation, такой как Free. Так мы реализуем необходимые
действия по управлению памятью. Поскольку тип контролируемый, процедуры
Initialize и Finalize автоматически вызываются при объявлении пула и его
уничтожении.</p>
<p>Чтобы создать пул мы объявляем объект этого типа, как обычно. Наконец,
необходимо привязать конкретный ссылочный тип к объекту-пулу.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Cell_Ptr_Pool</span><span class="p">:</span> <span class="n">My_Pool_Type</span> <span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">-- Размер пула — 1000</span>

<span class="kr">for</span> <span class="n">Cell_Ptr</span><span class="p">&#39;</span><span class="na">Storage_Pool</span> <span class="kn">use</span> <span class="n">Cell_Ptr_Pool</span><span class="p">;</span>
</pre></div>
</div>
<p>Важное преимущество пулов в том, что с их помощью можно уменьшить риск
фрагментации памяти, если распределять объекты одного размера в одном
пуле. Кроме того, мы можем написать свои алгоритмы распределения памяти
или даже уплотнения, если захотим. Существует также возможность
определить ссылочный тип локально, тогда и пул памяти можно определить
локально и он будет автоматически удален по завершении подпрограммы, что
исключит утечку памяти.</p>
<p>Пулы памяти были усовершенствованы в стандарте Ада 2012, где появились
вложенные пулы. Мы не будем останавливаться здесь на этом, отметим лишь,
что вложенные пулы — это части пула, уничтожаемые по отдельности.</p>
<p>Наконец, в качестве предохранителя от злоупотребления
Unchecked_Deallocation, можно использовать тот факт, что
Unchecked_Deallocation - это отдельный модуль компиляции. Следовательно,
везде, где он используется, в начале текста будет:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kn">with</span> <span class="n">Unchecked_Deallocation</span><span class="p">;</span>
</pre></div>
</div>
<p>Этот спецификатор контекста легко заметить при контроле качества
программы.</p>
</section>
<section id="id5">
<h2>Ограничения<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h2>
<p>Как мы уже знаем, есть общий механизм, гарантирующий отсутствие
использования некоторых свойств языка, и это директива компилятору
Restrictions. Если мы напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span> <span class="cp">Restrictions</span><span class="p">(</span><span class="n">No_Dependence</span> <span class="p">=&gt;</span> <span class="n">Unchecked_Deallocation</span><span class="p">);</span>
</pre></div>
</div>
<p>мы убедимся, что программа вообще не использует Unchecked_Deallocation —
компилятор проверит это.</p>
<p>Существует около пятидесяти таких ограничений, которые контролируют
различные аспекты программы. Многие из них узкоспециализированные и
относятся к многозадачным программам. Другие касаются распределения
памяти, например:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span> <span class="cp">Restrictions</span><span class="p">(</span><span class="n">No_Allocators</span><span class="p">);</span>

<span class="kr">pragma</span> <span class="cp">Restrictions</span><span class="p">(</span><span class="n">No_Implicit_Heap_Allocations</span><span class="p">);</span>
</pre></div>
</div>
<p>Первый полностью запрещает использование конструкции new, как например
new Cell'(...), а значит запрещает и динамическое распределение памяти
вообще. Иногда, некоторые реализации используют динамическое
распределение для хранения временных объектов. Это редкие случаи и
второй вариант запрещает их появление.</p>
</section>
</section>


           </div>
          </div>
          


<footer>
      
      

      
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
          
            <a href="chapter_08.html" class="btn btn-neutral float-right" title="Безопасный запуск" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
          
          
            <a href="chapter_06.html" class="btn btn-neutral" title="Безопасное создание объектов" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
          
        </div>
  


  <hr/>

  <div class="legal">
              Copyright &copy; 2022 AdaCore. All rights reserved.
              &nbsp;&nbsp;
              <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
              <br>
              <a href="https://www.adacore.com/company/legal">Legal</a>
              &nbsp; |  &nbsp;
              <a href="https://www.adacore.com/company/privacy">Privacy Policy</a>
              &nbsp; |  &nbsp;
              <a href="https://github.com/AdaCore/learn/issues">Report an Issue</a>
            </div> 

</footer>

        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>
  <button id="scrollToTopBtn" title="Go to top"><i class="fas fa-caret-square-up"></i></button>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
</script>


</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Безопасные типы данных &mdash; learn.adacore.com</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/style.6b9ffa6b650d4d2b2239.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/1.style.6b9ffa6b650d4d2b2239.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/main.6b9ffa6b650d4d2b2239.js"></script>
        <script src="../../../_static/1.main.6b9ffa6b650d4d2b2239.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Безопасные указатели" href="chapter_03.html" />
    <link rel="prev" title="Безопасный синтаксис" href="chapter_01.html" />
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-117428-14"></script>
<script type="text/javascript">
  if(!Cookies.get('AdaCore_staff')) {
    // Global site tag (gtag.js) - Google Analytics
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-117428-14');
    // End Global site tag (gtag.js) - Google Analytics

    // Google Tag Manager
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KD5HNRR');
    // End Google Tag Manager

    // Twitter universal website tag code
    !function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
    // Insert Twitter Pixel ID and Standard Event data below
    twq('init','o3mlc');
    twq('track','PageView');
    // End Twitter universal website tag code

    // LinkedIn Tracking Tags
    _linkedin_partner_id = "482585"; window._linkedin_data_partner_ids = window._linkedin_data_partner_ids || []; window._linkedin_data_partner_ids.push(_linkedin_partner_id);
    (function(){var s = document.getElementsByTagName("script")[0]; var b = document.createElement("script"); b.type = "text/javascript";b.async = true; b.src = "https://snap.licdn.com/li.lms-analytics/insight.min.js"; s.parentNode.insertBefore(b, s);})();
    // End LinkedIn Tracking Tags
  }
</script>
  <!--  Essential META Tags -->
<meta property="og:title" content=“learn.adacore.com">
<meta property="og:description" content="An interactive learning platform to teach the Ada and SPARK programming languages.">
<meta property="og:image" content="https://learn.adacore.com/_static/learn_meta_img.jpeg">
<meta property="og:url" content="https://learn.adacore.com">
<meta name="twitter:card" content="summary_large_image">

<!--  Non-Essential, But Recommended -->
<meta property="og:site_name" content="learn.adacore.com">
<meta name="twitter:image:alt" content="An interactive learning platform to teach the Ada and SPARK programming languages.">

<!--  Non-Essential, But Required for Analytics -->
<meta name="twitter:site" content="@AdaCoreCompany">

</head>

<body class="wy-body-for-nav">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KD5HNRR"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <!-- LinkedIn Tracking Tags (noscript) -->
  <noscript> <img height="1" width="1" style="display:none;" alt="" src="https://dc.ads.linkedin.com/collect/?pid=482585&fmt=gif" /> </noscript>
  <!-- End LinkedIn Tracking Tags (noscript) -->

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">Подробнее</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Курсы</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../intro-to-ada-ru/index.html">Введение в язык Ада</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html">Введение</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id2">История</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id3">Ада сегодня</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#id7">Философия</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/introduction.html#spark">SPARK</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html">Императивы языка</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#hello-world">Hello world</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id2">Условный оператор</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id3">Циклы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#for">Циклы for</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id4">Простой цикл</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#while">Циклы while</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id5">Оператор выбора</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id6">Зоны описания</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id7">Условные выражения</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id8">Условное выражение</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/imperative_language.html#id9">Выражение выбора</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html">Подпрограммы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id2">Подпрограммы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id3">Вызовы подпрограмм</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id4">Вложенные подпрограммы</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id5">Вызов функций</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id6">Виды параметров</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id7">Вызов процедуры</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#in">Параметры in</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#in-out">Параметры in out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#out">Параметры out</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#id8">Предварительное объявление подпрограмм</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/subprograms.html#intro-ada-ru-subprogram-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html">Модульное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id2">Пакеты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-use-clause">Использование пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id4">Тело пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-childpackages">Дочерние пакеты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id6">Дочерний пакет от дочернего пакета</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id7">Множественные потомки</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#id8">Видимость</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/modular_programming.html#intro-ada-ru-package-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html">Сильно типизированный язык</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-whatisatype">Что такое тип?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#integers">Целочисленные типы - Integers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id3">Семантика операций</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id4">Беззнаковые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-enumtypes">Перечисления</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id7">Типы с плавающей запятой</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id8">Основные свойства</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id9">Точность типов с плавающей запятой</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id10">Диапазон значений для типов с плавающей запятой</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id11">Строгая типизация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id12">Производные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#id13">Подтипы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/strongly_typed_language.html#intro-ada-ru-subtypealiases">Подтипы в качестве псевдонимов типов</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html">Записи</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#intro-ada-ru-record-type-declaration">Объявление типа записи</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#id3">Агрегаты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#id4">Извлечение компонент</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/records.html#record-comp-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html">Массивы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id2">Объявление типа массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id3">Доступ по индексу</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id4">Более простые объявления массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id5">Атрибут диапазона</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#intro-ada-ru-unconstrainedarraytypes">Неограниченные массивы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#string">Предопределенный тип String</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id7">Ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id8">Возврат неограниченных массивов</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id9">Объявление массивов (2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#id10">Отрезки массива</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/arrays.html#intro-ada-ru-object-renaming">Переименование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html">Подробнее о типах</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#id2">Агрегаты: краткая информация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#c">Cовмещение и квалифицированные выражения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_types.html#id4">Символьные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html">Ссылочные типы</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id2">Введение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#allocation">Выделение (allocation) памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#intro-ada-ru-access-dereferencing">Извлечение по ссылке</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id4">Другие особенности</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/access_types.html#id5">Взаимно рекурсивные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html">Подробнее о записях</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#id2">Типы записей динамически изменяемого размера</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#id3">Записи с дискриминантом</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/more_about_records.html#c">Записи c вариантами</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html">Типы с фиксированной запятой</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html#id2">Десятичные типы с фиксированной запятой</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/fixed_point_types.html#id3">Обычные типы с фиксированной запятой</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html">Изоляция</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id3">Простейшая инкапсуляция</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id4">Абстрактные типы данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id5">Лимитируемые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/privacy.html#id7">Дочерние пакеты и изоляция</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html">Настраиваемые модули</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id2">Введение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id3">Объявление формального типа</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id4">Объявление формального объекта</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id5">Определение тела настраиваемого модуля</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id6">Конкретизация настройки</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id7">Настраиваемые пакеты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id8">Формальные подпрограммы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id9">Пример: конкретизация ввода/вывода</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id10">Пример: АТД</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id11">Пример: Обмен</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id12">Пример: Обратный порядок элементов</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/generics.html#id13">Пример: Тестовое приложение</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html">Исключения</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id2">Объявление исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id3">Возбуждение исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id4">Обработка исключения</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/exceptions.html#id5">Предопределенные исключения</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html">Управление задачами</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id2">Задачи</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id5">Простая задача</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id6">Простая синхронизация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id7">Оператор задержки</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id8">Синхронизация: рандеву</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id9">Обрабатывающий цикл</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id10">Циклические задачи</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id11">Защищенные объекты</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id12">Простой объект</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id13">Входы</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id14">Задачные и защищенные типы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#intro-ada-ru-tasktypes">Задачные типы</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/tasking.html#id16">Защищенные типы</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html">Контрактное проектирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id2">Пред- и постусловия</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id3">Предикаты</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/contracts.html#id4">Инварианты типа</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html">Взаимодействие с языком C</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id1">Многоязычный проект</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id2">Соглашение о типах</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id3">Подпрограммы на других языках</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id4">Вызов подпрограмм C из Ады</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id5">Вызов Ада подпрограмм из C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id6">Внешние переменные</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id7">Использование глобальных переменных C в Аде</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id8">Использование переменных Ада в C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id9">Автоматическое создание связок</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/interfacing_with_c.html#id10">Адаптация связок</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html">Объектно-ориентированное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id2">Производные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id3">Теговые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id5">Надклассовые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id6">Операции диспетчеризации</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id7">Точечная нотация</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id8">Личные и лимитируемые типы с тегами</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/object_oriented_programming.html#id9">Надклассовые ссылочные типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html">Стандартная библиотека: Контейнеры</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id2">Векторы</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id3">Создание экземпляра</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id4">Инициализация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id5">Добавление элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id6">Доступ к первому и последнему элементам</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id7">Итерация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id8">Поиск и изменение элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id9">Вставка элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id10">Удаление элементов</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id11">Другие операции</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id12">Множества</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id13">Инициализация и итерация</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id14">Операции с элементами</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id15">Другие операции</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id16">Отображения для неопределенных типов</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id17">Хэшированные отображения</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id18">Упорядоченные отображения</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_containers.html#id19">Сложность</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html">Стандартная библиотека: Дата и время</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#intro-ada-ru-datestimes">Обработка даты и времени</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id3">Задержка с использованием даты</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id4">Режим реального времени</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_dates_times.html#id5">Анализ производительности</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html">Стандартная библиотека: Строки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id2">Операции со строками</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id3">Ограничение строк фиксированной длины</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#id4">Ограниченные строки</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_strings.html#intro-ada-ru-unboundedstrings">Неограниченные строки</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html">Стандартная библиотека: Файлы и потоки</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id2">Текстовый ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id3">Последовательный ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id4">Прямой ввод-вывод</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_files_streams.html#id5">Потоковый ввод-вывод</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html">Стандартная библиотека: Numerics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id1">Элементарные функции</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id2">Генерация случайных чисел</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id3">Комплексные числа</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/standard_library_numerics.html#id4">Работа с векторами и матрицами</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html">Приложения</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#a">Приложение A: Формальные типы настройки</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#id2">Неопределенные версии типов</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../intro-to-ada-ru/chapters/appendices.html#b">Приложение B: Контейнеры</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Безопасное и надежное программное обеспечение</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Вступление</a></li>
<li class="toctree-l2"><a class="reference internal" href="foreword.html">Предисловие</a></li>
<li class="toctree-l2"><a class="reference internal" href="chapter_01.html">Безопасный синтаксис</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id2">Присваивание и проверка на равенство</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id3">Группы инструкций</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id4">Именованное сопоставление</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_01.html#id5">Целочисленные литералы</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Безопасные типы данных</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">Использование индивидуальных типов</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Перечисления и целые</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Ограничения и подтипы</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Предикаты подтипов</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Массивы и ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Установка начальных значений по умолчанию</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">«Вещественные ошибки»</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_03.html">Безопасные указатели</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id2">Ссылки, указатели и адреса</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id3">Ссылочные типы и строгая типизация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id4">Ссылочные типы и контроль доступности</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id5">Ссылки на подпрограммы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_03.html#id6">Вложенные подпрограммы в качестве параметров</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_04.html">Безопасная архитектура</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id2">Спецификация и тело пакета</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id3">Приватные типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id4">Контрактная модель настраиваемых модулей</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id5">Дочерние модули</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id6">Модульное тестирование</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id7">Взаимозависимые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_04.html#id8">Контрактное программирование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_05.html">Безопасное объектно‐ориентированное программирование</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id2">ООП вместо структурного программирования</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#overriding">Индикатор overriding</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id3">Запрет диспетчеризации вызова подпрограмм</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id4">Интерфейсы и множественное наследование</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_05.html#id5">Взаимозаменяемость</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_06.html">Безопасное создание объектов</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id2">Переменные и константы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id3">Функция-конструктор</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id4">Лимитируемые типы</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_06.html#id5">Контролируемые типы</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_07.html">Безопасное управление памятью</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id2">Переполнение буфера</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id3">Динамическое распределение памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id4">Пулы памяти</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_07.html#id5">Ограничения</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_08.html">Безопасный запуск</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id2">Предвыполнение</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id3">Директивы компилятору, связанные с предвыполнением</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_08.html#id4">Динамическая загрузка</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_09.html">Безопасная коммуникация</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id2">Представление данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id3">Корректность данных</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id4">Взаимодействие с другими языками</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id5">Потоки ввода/вывода</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_09.html#id6">Фабрики объектов</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_10.html">Безопасный параллелизм</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id2">Операционные системы и задачи</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id3">Защищенные объекты</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id4">Рандеву</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id5">Ограничения</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#ravenscar">Ravenscar</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id6">Безопасное завершение</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_10.html#id7">Время и планирование</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chapter_11.html">Сертификация с помощью SPARK</a><ul>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id1">Контракты</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id2">SPARK — подмножество языка Ада</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id3">Формальные методы анализа</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id4">Гибридная верификация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id5">Примеры</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id6">Сертификация</a></li>
<li class="toctree-l3"><a class="reference internal" href="chapter_11.html#id7">Дальнейший процесс</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html">Заключение</a></li>
<li class="toctree-l2"><a class="reference internal" href="biblio.html">Список литературы</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
  <i data-toggle="wy-nav-top" class="fas fa-bars"></i>
    <a href="../../../index.html">
    <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
  </a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>Безопасные типы данных<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<p>В данной главе речь пойдет не об ускорении набора текста программы, а о
механизме, помогающем обнаружить еще больше ошибок и опечаток.</p>
<p>Этот специально разработанный и встроенный в язык механизм часто
называют механизмом строгой типизации.</p>
<p>В ранних языках, таких как Fortran и Algol, все обрабатываемые данные
имели числовой тип. В конце концов, ведь компьютер изначально способен
обращаться только с числами, зачастую закодированными в бинарном виде
целыми либо числами с плавающей точкой. В более поздних языках, начиная
с Pascal, появилась возможность оперировать объектами на более
абстрактном уровне. Так, использование перечислимых типов (в Pascal их
называют скалярными) дает нам несомненное преимущество обращаться с
цветами, как с цветами, хотя они в итоге будут обрабатываться
компьютером, как числа.</p>
<p>Эта идея в языке Ада получила дальнейшее развитие, в то время как другие
языки продолжают трактовать скалярные типы, как числовые, упуская
ключевую идею абстракции, суть которой в разделении смыслового
предназначения и машинного представления.</p>
<section id="id2">
<h2>Использование индивидуальных типов<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h2>
<p>Допустим, мы наблюдаем за качеством производимой продукции и
подсчитываем число испорченных изделий. Для этого мы считаем годные и
негодные образцы. Нам нужно остановить производство, если количество
негодных образцов привысит некоторый лимит, либо если мы изготовим
заданное количество годных изделий. В C и C++ мы могли бы иметь
следующие переменные:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">badcount</span><span class="p">,</span><span class="w"> </span><span class="n">goodcount</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">b_limit</span><span class="p">,</span><span class="w"> </span><span class="n">g_limit</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>и далее:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">badcount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">badcount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">badcount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b_limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Аналогично для годных образцов. Но, т. к. все это целые числа, ничто не
помешает нам случайно написать по ошибке:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">goodcount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b_limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>где нам на самом деле нужно было бы написать g_limit. Это может быть
результатом приема «скопировать и вставить», либо просто опечатка (b и g
находятся близко на клавиатуре). Как бы то ни было, компилятор будет
доволен, а мы — едва ли.</p>
<p>Так может случиться в любом языке. Но в Аде есть способ выразить наши
действия более точно. Мы можем написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Goods</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Bads</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Integer</span><span class="p">;</span>
</pre></div>
</div>
<p>Эти определения вводят новые типы с теми же характеристиками, что и
предопределенный тип Integer (например будут иметь операции + и -). Хотя
реализация этих типов ничем не отличается, сами же типы различны. Теперь
мы можем написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Good_Count</span><span class="p">,</span> <span class="n">G_Limit</span> <span class="p">:</span> <span class="n">Goods</span><span class="p">;</span>
<span class="n">Bad_Count</span><span class="p">,</span> <span class="n">B_Limit</span> <span class="p">:</span> <span class="n">Bads</span><span class="p">;</span>
</pre></div>
</div>
<p>Разделив таким образом понятия на две группы, мы достигнем того, что
компилятор обнаружит ошибки, когда мы перепутаем сущности разных групп и
предотвратит запуск некорректной программы. Следующий код не вызовет
нареканий:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Bad_Count</span> <span class="p">:=</span> <span class="n">Bad_Count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">if</span> <span class="n">Bad_Count</span> <span class="o">=</span> <span class="n">B_Limit</span> <span class="kr">then</span>
</pre></div>
</div>
<p>Но следующая ошибка будет обнаружена</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span> <span class="n">Good_Count</span> <span class="o">=</span> <span class="n">B_Limit</span> <span class="kr">then</span> <span class="c1">--  Illegal</span>
</pre></div>
</div>
<p>ввиду несовпадения типов.</p>
<p>Когда нам потребуется действительно смешать типы, например, чтобы
сравнить количество годных и негодных образцов, мы можем использовать
преобразование типов. Например:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span> <span class="n">Good_Count</span> <span class="o">=</span> <span class="n">Goods</span> <span class="p">(</span><span class="n">B_Limit</span><span class="p">)</span> <span class="kr">then</span>
</pre></div>
</div>
<p>Другим примером может служить вычисление разницы счетчиков образцов:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Diff</span> <span class="p">:</span> <span class="kt">Integer</span> <span class="p">:=</span> <span class="kt">Integer</span> <span class="p">(</span><span class="n">Good_Count</span><span class="p">)</span> <span class="o">-</span> <span class="kt">Integer</span> <span class="p">(</span><span class="n">Bad_Count</span><span class="p">);</span>
</pre></div>
</div>
<p>Аналогично можно избежать путаницы с типами с плавающей точкой.
Например, имея дело с весом и ростом, как в примере из предыдущей главы,
вместо того, чтобы писать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Height</span><span class="p">,</span> <span class="n">My_Weight</span> <span class="p">:</span> <span class="kt">Float</span><span class="p">;</span>
</pre></div>
</div>
<p>было бы лучше написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Inches</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Float</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Pounds</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Float</span><span class="p">;</span>
<span class="n">My_Height</span> <span class="p">:</span> <span class="n">Inches</span> <span class="p">:=</span> <span class="mf">68.0</span><span class="p">;</span>
<span class="n">My_Weight</span> <span class="p">:</span> <span class="n">Pounds</span> <span class="p">:=</span> <span class="mf">168.0</span><span class="p">;</span>
</pre></div>
</div>
<p>И это позволит компилятору предотвратить путаницу.</p>
</section>
<section id="id3">
<h2>Перечисления и целые<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h2>
<p>В главе «Безопасный синтаксис» мы обсуждали пример с железной дорогой, в
котором была следующая проверка:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">the_signal</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">clean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span> <span class="n">The_Signal</span> <span class="o">=</span> <span class="n">Clean</span> <span class="kr">then</span> <span class="p">...</span> <span class="kr">end</span> <span class="kr">if</span><span class="p">;</span>
</pre></div>
</div>
<p>на языке C и Ада соответственно. На C переменная the_signal и
соответствующие константы могут быть определены так:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">signal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">danger</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">caution</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">clear</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">signal</span><span class="w"> </span><span class="n">the_signal</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Эта удобная запись на самом деле всего лишь сокращение для описания
констант danger, caution и clear типа int. И сама переменная the_signal
имеет тип int. Как следствие, ничего не помешает нам присвоить
переменной the_signal абсолютно бессмысленное значение, например 4. В
частности, такие значения могут возникать при использовании не
инициализированных переменных. Хуже того, если мы в другой части
программы оперируем химическими элементами и используем имена anion,
cation, нам ничего не помешает перепутать cation и caution. Мы можем
также использовать где-то женские имена betty и clare, либо названия
оружия dagger и spear. И снова ничто не предотвратит опечатки типа
dagger вместо danger и clare вместо clear.</p>
<p>В Аде мы пишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Signal</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Danger</span><span class="p">,</span> <span class="nv">Caution</span><span class="p">,</span> <span class="nv">Clear</span><span class="p">);</span>
<span class="n">The_Signal</span> <span class="p">:</span> <span class="n">Signal</span> <span class="p">:=</span> <span class="n">Danger</span><span class="p">;</span>
</pre></div>
</div>
<p>и путаница исключена, потому, что перечислимый тип в Аде - это
совершенно отдельный тип и он не имеет отношения к целому типу. Если мы
также где-то имеем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Ions</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Anion</span><span class="p">,</span> <span class="nv">Caution</span><span class="p">);</span>
<span class="kd">type</span> <span class="kt">Names</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Anne</span><span class="p">,</span> <span class="nv">Betty</span><span class="p">,</span> <span class="nv">Clare</span><span class="p">,</span> <span class="p">...);</span>
<span class="kd">type</span> <span class="kt">Weapons</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Arrow</span><span class="p">,</span> <span class="nv">Bow</span><span class="p">,</span> <span class="nv">Dagger</span><span class="p">,</span> <span class="nv">Spear</span><span class="p">);</span>
</pre></div>
</div>
<p>то компилятор предотвратит путаницу этих понятий в момент компиляции.
Более того, компилятор не даст присвоить Clear значение Danger, так как
оба они литералы и присваивание для них также бессмысленно, как попытка
поменять значение литерала 5 написав:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="p">:=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>На машинном уровне все перечисленные типы кодируются как целые и мы
можем получить код для кодировки по умолчанию, используя атрибут Pos,
когда нам это действительно необходимо:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Danger_Code</span> <span class="p">:</span> <span class="kt">Integer</span> <span class="p">:=</span> <span class="n">Signal</span><span class="p">&#39;</span><span class="na">Pos</span> <span class="p">(</span><span class="n">Danger</span><span class="p">);</span>
</pre></div>
</div>
<p>Мы также можем ввести свою кодировку. Позже мы остановимся на этом в
главе «Безопасная коммуникация».</p>
<p>Между прочим, один из важнейших типов Ады, Boolean, имеет следующее
определение:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Boolean</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">False</span><span class="p">,</span> <span class="nv">True</span><span class="p">);</span>
</pre></div>
</div>
<p>Результат операций сравнения, таких как The_Signal = Clear имеет тип
Boolean. Также существуют предопределенные операции and, or, not для
этого типа. В Аде невозможно использовать числовые значение вместо
Boolean и наоборот. В то время, как в C, как мы помним, результат
сравнения вернет значение целого типа, ноль означает ложно, а не нулевое
значение — истинно. Снова возникает опасность в коде:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">the_signal</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">clean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Как ранее упоминалось, пропустив один знак равенства, вместо выражения
сравнения мы получим присваивание. Поскольку целочисленный результат
воспринимается в C как значение условия, ошибка остается необнаруженной.
Таким образом, данный пример иллюстрирует сразу несколько возможных мест
для ошибки:</p>
<ul class="simple">
<li><p>использование знака = для присваивания;</p></li>
<li><p>допустимость присваивания там, где ожидается выражение;</p></li>
<li><p>использование числовых значений вместо Boolean в условных выражениях.</p></li>
</ul>
<p>Большинство из этого просочилось в C++. Ни одного пункта не присутствует
в Аде.</p>
</section>
<section id="id4">
<h2>Ограничения и подтипы<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<p>Довольно часто значение некоторой переменной должно находится в
определенном диапазоне, чтобы иметь какой-то смысл. Хорошо бы иметь
возможность обозначить это в программе, выразив, таким образом, наши
представления об ограничениях окружающего мира в явном виде. Например,
мой вес My_Weight не может быть меньше нуля и, я искренне надеюсь,
никогда не привысит 300 фунтов. Таким образом мы можем определить:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Weight</span> <span class="p">:</span> <span class="kt">Float</span> <span class="kr">range</span> <span class="mf">0.0</span> <span class="p">..</span> <span class="mf">300.0</span><span class="p">;</span>
</pre></div>
</div>
<p>а если мы продвинутые программисты и заранее определили тип Phounds, то:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Weight</span> <span class="p">:</span> <span class="n">Phounds</span> <span class="kr">range</span> <span class="mf">0.0</span> <span class="p">..</span> <span class="mf">300.0</span><span class="p">;</span>
</pre></div>
</div>
<p>Далее, если программа ошибочно рассчитает вес, не вписывающийся в
заданный диапазон, и попытается присвоить его переменной My_Weight так:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Weight</span> <span class="p">:=</span> <span class="n">Compute_Weight</span> <span class="p">(...);</span>
</pre></div>
</div>
<p>то во время исполнения будет возбуждено исключение Constraint_Error. Мы
можем перехватить это исключение в каком-то месте программы и
предпринять некоторые корректирующие действия. Если мы не сделаем этого,
программа завершиться, выдав диагностическое сообщение с указанием, где
произошло нарушение ограничения. Все это происходит автоматически —
необходимые проверки компилятор сам вставит во всех нужных местах.
(Придирчивый читатель, знакомый с языком Ада, заметит, что наша
формулировка «программа завершится» нуждается в уточнении, поскольку
верна только для последовательных программ. Ситуация в параллельном
программировании несколько отличается от описанной, но это выходит за
границы темы, обсуждаемой в этой главе.)</p>
<p>Идея ввести поддиапазоны впервые появилась в Pascal и была далее развита
в Аде. Она не доступна в других языках, где нам бы пришлось повсюду
вписывать свои проверки, и вряд ли мы бы стали этим озадачиваться. Как
следствие, любые ошибки, приводящие к нарушению этих границ, становится
обнаружить гораздо труднее. Если бы мы знали, что любое значения веса,
которым оперирует программа, находится в указанном диапазоне, то вместо
того, чтобы добавлять ограничение в определение каждой переменной, мы
могли бы наложить его прямо на тип Pounds:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Pounds</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Float</span> <span class="kr">range</span> <span class="mf">0.0</span> <span class="p">..</span> <span class="mf">300.0</span><span class="p">;</span>
</pre></div>
</div>
<p>С другой стороны, если некоторые значения веса в программе неограничены,
а известно лишь, что значение веса человека находится в указанном
диапазоне, то мы можем написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Pounds</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Float</span><span class="p">;</span>
<span class="kd">subtype</span> <span class="kt">People_Pounds</span> <span class="kr">is</span> <span class="n">Pounds</span> <span class="kr">range</span> <span class="mf">0.0</span> <span class="p">..</span> <span class="mf">300.0</span><span class="p">;</span>

<span class="n">My_Weight</span> <span class="p">:</span>  <span class="n">People_Pounds</span><span class="p">;</span>
</pre></div>
</div>
<p>Аналогично мы можем накладывать ограничения на целочисленные и
перечислимые типы. Так, при подсчете образцов мы подразумеваем, что их
количество не будет меньше нуля или больше 1000. Тогда мы напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Goods</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Integer</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="mi">1000</span><span class="p">;</span>
</pre></div>
</div>
<p>Но если мы хотим лишь убедиться, что значения неотрицательные и не хотим
накладывать ограничение на верхнюю границу диапазона, то мы напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Goods</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Integer</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="kt">Integer</span><span class="p">&#39;</span><span class="na">Last</span><span class="p">;</span>
</pre></div>
</div>
<p>где Integer'Last обозначает наибольшее значение типа Integer.
Подмножества положительных и неотрицательных целых чисел используются
повсеместно, поэтому для них Ада предоставляет стандартные подтипы:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">subtype</span> <span class="kt">Natural</span> <span class="kr">is</span> <span class="kt">Integer</span> <span class="kr">range</span> <span class="mi">0</span> <span class="p">..</span> <span class="kt">Integer</span><span class="p">&#39;</span><span class="na">Last</span><span class="p">;</span>
<span class="kd">subtype</span> <span class="kt">Positive</span> <span class="kr">is</span> <span class="kt">Integer</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="kt">Integer</span><span class="p">&#39;</span><span class="na">Last</span><span class="p">;</span>
</pre></div>
</div>
<p>Можно определить тип Goods:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Goods</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">Natural</span><span class="p">;</span>
</pre></div>
</div>
<p>где ограничена только нижняя граница диапазона, что нам и нужно.</p>
<p>Пример ограничения для перечислимого типа может быть следующим:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Day</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Monday</span><span class="p">,</span> <span class="nv">Tuesday</span><span class="p">,</span> <span class="nv">Wednesday</span><span class="p">,</span> <span class="nv">Thursday</span><span class="p">,</span>
             <span class="nv">Friday</span><span class="p">,</span> <span class="nv">Saturday</span><span class="p">,</span> <span class="nv">Sunday</span><span class="p">);</span>
<span class="kd">subtype</span> <span class="kt">Weekday</span> <span class="kr">is</span> <span class="n">Day</span> <span class="kr">range</span> <span class="n">Monday</span> <span class="p">..</span> <span class="n">Friday</span><span class="p">;</span>
</pre></div>
</div>
<p>Далее автоматические проверки предотвратят присваивание Sunday
переменным типа Weekday.</p>
<p>Введение ограничений, подобных описанным выше, может показаться
утомительным занятием, но это делает программу более понятной. Более
того, это позволяет во время компиляции и во время исполнения убедиться,
что наши предположения, выраженные в коде, действительно верны.</p>
</section>
<section id="id5">
<h2>Предикаты подтипов<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h2>
<p>Подтипы в Аде очень полезны, они позволяют заранее обнаружить такие
ошибки, которые в других языках могут остаться незамеченными и привести
затем к краху программы. Но, при всей полезности, механизм подтипов
несколько ограничен, т. к. разрешает указывать лишь непрерывные
диапазоны значений для числовых и перечислимых типов.</p>
<p>Это подтолкнуло разработчиков языка Ада 2012 ввести предикаты подтипов,
которые можно добавлять к определениям типов и подтипов. Как показала
практика, необходимо иметь два различных механизма в зависимости от
того, является ли предикат статическим или динамическим. Оба используют
выражения типа Boolean, но статический предикат разрешает лишь некоторые
типы выражений, в то время как динамический применим в более общем
случае.</p>
<p>Допустим мы оперируем сезонами года и имеем следующее определение
месяцев:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Month</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Jan</span><span class="p">,</span> <span class="nv">Feb</span><span class="p">,</span> <span class="nv">Mar</span><span class="p">,</span> <span class="nv">Apr</span><span class="p">,</span> <span class="nv">May</span><span class="p">,</span> <span class="nv">Jun</span><span class="p">,</span>
               <span class="nv">Jul</span><span class="p">,</span> <span class="nv">Aug</span><span class="p">,</span> <span class="nv">Sep</span><span class="p">,</span> <span class="nv">Oct</span><span class="p">,</span> <span class="nv">Nov</span><span class="p">,</span> <span class="nv">Dec</span><span class="p">);</span>
</pre></div>
</div>
<p>Мы хотим иметь отдельные подтипы для каждого сезона. Для северного
полушария зима включает декабрь, январь и февраль. (С точки зрения
солнцестояния и равноденствия зима длиться с 21 декабря по 21 марта, но,
как по мне, март больше относится к весне, чем к зиме, а декабрь ближе к
зиме, чем к осени.) Поэтому нам нужен подтип, включающий значения Dec ,
Jan и Feb. Мы не можем воспользоваться ограничением диапазона здесь, но
можем использовать статический предикат следующим образом:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">subtype</span> <span class="kt">Winter</span> <span class="kr">is</span> <span class="n">Month</span>
  <span class="kr">with</span> <span class="n">Static_Predicate</span> <span class="p">=&gt;</span> <span class="n">Winter</span> <span class="ow">in</span> <span class="n">Dec</span> <span class="p">|</span> <span class="n">Jan</span> <span class="p">|</span> <span class="n">Feb</span><span class="p">;</span>
</pre></div>
</div>
<p>Это гарантирует, что объекты типа Winter могут содержать только Dec ,
Jan и Feb. Заметьте, что имя подтипа (Winter) в выражении означает
текущее значение подтипа.</p>
<p>Подобная синтаксическая конструкция со словом with введена в Ада 2012 и
называется аспектом.</p>
<p>Данный аспект проверяется при инициализации переменной по умолчанию,
присваивании, преобразовании типа, передаче параметра и т. д. Если
проверка не проходит, то возбуждается исключение Assertion_Error. (Мы
можем включить или отключить проверку предиката при помощи pragma
Assertion_Policy; включает проверку аргумент с именем Check.)</p>
<p>Если условие проверки не является статическим, то необходимо
использовать Dynamic_Predicatre аспект. Например:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">T</span> <span class="kr">is</span> <span class="p">...;</span>
<span class="kd">function</span> <span class="nf">Is_Good</span> <span class="p">(</span><span class="nv">X</span> <span class="p">: </span><span class="nv">T</span><span class="p">)</span> <span class="kr">return</span> <span class="kt">Boolean</span><span class="p">;</span>
<span class="kd">subtype</span> <span class="kt">Good_T</span> <span class="kr">is</span> <span class="n">T</span>
  <span class="kr">with</span> <span class="n">Dynamic_Predicate</span> <span class="p">=&gt;</span> <span class="n">Is_Good</span> <span class="p">(</span><span class="nv">Good_T</span><span class="p">);</span>
</pre></div>
</div>
<p>Заметьте, что подтип с предикатом невозможно использовать в некоторых
ситуациях, таких как ограничения индекса. Это позволяет избежать таких
странных вещей, как массивы «с дырками». Однако подтипы со статическим
предикатом можно использовать в for-циклах для перебора всех значений
подтипа. Т.е. мы можем написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">Winter</span> <span class="kr">loop</span> <span class="p">...</span>
</pre></div>
</div>
<p>В цикле M получит последовательно значения Jan, Feb, Dec, т. е. по
порядку определения литералов перечислимого типа.</p>
</section>
<section id="id6">
<h2>Массивы и ограничения<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h2>
<p>Массив - это множество элементов с доступом по индексу. Предположим, что
у нас есть пара игральных костей, и мы хотим подсчитать, сколько раз
выпало каждое возможное значение (от 2 до 12). Так как всего возможных
значений 11, на C мы бы написали:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">counters</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">throw</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>объявив таким образом 11 переменных с именами от counters[0] до
counters[10] и целочисленную переменную throw.</p>
<p>При подсчете очередного значения мы бы написали:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">throw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">counters</span><span class="p">[</span><span class="n">throw</span><span class="mi">-2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counters</span><span class="p">[</span><span class="n">throw</span><span class="mi">-2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Заметьте, что нам пришлось уменьшить значение на 2, т. к. индексы
массивов в C всегда отсчитываются от нуля (иначе говоря, нижняя граница
массива — всегда ноль). Предположим, что-то пошло не так (или какой-то
шутник подсунул нам кость с 7 точками, или используемый нами генератор
случайных чисел был неправильно написан) и throw стало равно 13. Что
произойдет? Программа на C не обнаружит ошибку. Просто высчитает, где
могло бы располагаться counters[11] и прибавит туда единицу. Вероятнее
всего, будет увеличено значение переменной throw, т. к. она объявлена
сразу после массива. Дальше все пойдет непредсказуемо.</p>
<p>Этот пример демонстрирует печально известную проблему переполнения
буфера. Она является причиной множества серьезных и трудно
обнаруживаемых неисправностей. В конечном счете это может привести к
появлению бреши в защите через которую проходят атаки вирусов на
системы, такие как Windows. Мы обсудим это подробнее в главе 7
Безопасное управление памятью.</p>
<p>Давайте теперь рассмотрим аналогичную программу на Аде:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Counters</span> <span class="p">:</span> <span class="kr">array</span> <span class="p">(</span><span class="mi">2</span> <span class="p">..</span> <span class="mi">12</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="n">Throw</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="n">затем</span><span class="p">:</span>
<span class="n">Throw</span> <span class="p">:=</span> <span class="p">...;</span>
<span class="n">Counters</span> <span class="p">(</span><span class="n">Throw</span><span class="p">)</span> <span class="p">:=</span> <span class="n">Counters</span> <span class="p">(</span><span class="n">Throw</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Во время исполнения программы на Аде выполняются проверки, запрещающие
нам читать/писать элементы за границами массива, поэтому если Throw
случайно станет 13, то будет возбуждено исключение Constraint_Error и мы
избежим непредсказуемого поведения программы.</p>
<p>Заметим, что в Аде можно определить не только верхнюю, но и нижнюю
границу массива. Нет нужды отсчитывать элементы от нуля. Массивы в
реальных программах чаще имеют нижнюю границу равную единице, чем нулю.
Задав нижнюю границу массива равную двум, мы получаем возможность в
качестве индекса использовать непосредственно значение переменной Throw
без необходимости вычитать соответствующее смещение, как в C версии.</p>
<p>Настоящая ошибка данной программы случается не в тот момент, когда
происходит выход за пределы массива, а когда Throw выходит за корректный
диапазон значений. Эту ситуацию можно выявить раньше, если наложить
ограничение на Throw:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Throw</span> <span class="p">:</span> <span class="kt">Integer</span> <span class="kr">range</span> <span class="mi">2</span> <span class="p">..</span> <span class="mi">12</span><span class="p">;</span>
</pre></div>
</div>
<p>и теперь исключение Constraint_Error будет возбуждено в момент, когда
Throw станет 13. Как следствие, компилятор будет в состоянии определить,
что значение Throw всегда попадает в границы массива и соответствующие
проверки при доступе к массиву не нужны там, где в качестве индекса
используется Throw. В итоге, мы можем избавиться от дублирования кода,
написав:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">subtype</span> <span class="kt">Dice_Range</span> <span class="kr">is</span> <span class="kt">Integer</span> <span class="kr">range</span> <span class="mi">2</span> <span class="p">..</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">Throw</span> <span class="p">:</span> <span class="n">Dice_Range</span><span class="p">;</span>
<span class="n">Counters</span> <span class="p">:</span> <span class="kr">array</span> <span class="p">(</span><span class="n">Dice_Range</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">Integer</span><span class="p">;</span>
</pre></div>
</div>
<p>Преимущество в том, что если нам в дальнейшем нужно будет поменять
диапазон (например, добавив третью кость мы получим значения в диапазоне
3 .. 18), то это нужно будет сделать только в одном месте.</p>
<p>Значение проверок диапазона во время тестирования огромно. Но для
программ в промышленной эксплуатации, при желании, эти проверки можно
отключить. Подобные проверки применяются не только в Аде. Еще в 1962
компилятор Whetstone Algol 60 мог делать так же. Проверки диапазона
определены в стандарте языка (как и в Java, C#).</p>
<p>Наверное стоит упомянуть, что мы можем давать имена и для
типов-массивов. Их называют индексируемыми типами. Если у нас есть
несколько множеств счетчиков, то будет лучше написать:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Counter_Array</span> <span class="kr">is</span> <span class="kr">array</span> <span class="p">(</span><span class="n">Dice_Range</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="n">Counters</span> <span class="p">:</span> <span class="n">Counter_Array</span><span class="p">;</span>
<span class="n">Old_Counter</span> <span class="p">:</span> <span class="n">Counter_Array</span><span class="p">;</span>
</pre></div>
</div>
<p>и затем, когда нам потребуется скопировать все элементы массива Counters
в соответствующие элементы массива Old_Counters, мы просто напишем:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Old_Counters</span> <span class="p">:=</span> <span class="n">Counters</span><span class="p">;</span>
</pre></div>
</div>
<p>Именованные индексируемые типы есть далеко не во всех языках.
Преимущество именованных типов в том, что они вводят явную абстракцию,
как в примере с подсчетом годных и негодных образцов. Чем больше мы даем
компилятору информации о том, что мы хотим сделать, тем больше у него
возможностей проверить, что наша программа имеет смысл.</p>
<p>Все объекты типа Counter_Array имеют равное количество элементов,
определенное типом Dice_Range. Соответственно такой тип называется
ограниченным индексируемым типом. Иногда удобнее определить более гибкий
тип для объектов, имеющих одинаковый тип индекса и тип элементов, но
различное количество элементов. К примеру:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Float_Array</span> <span class="kr">is</span> <span class="kr">array</span> <span class="p">(</span><span class="kt">Positive</span> <span class="kr">range</span> <span class="p">&lt;&gt;)</span> <span class="kr">of</span> <span class="kt">Integer</span><span class="p">;</span>
</pre></div>
</div>
<p>Тип Float_Array назвается неограниченным индексируемым типом. При
создании объекта такого типа необходимо указать нижнюю и верхнюю границы
при помощи ограничения либо задав начальное значение массива.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Array</span> <span class="p">:</span> <span class="n">Float_Array</span> <span class="p">(</span><span class="mi">1</span> <span class="p">..</span> <span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
<p>Любознательный читатель может спросить, что будет если верхняя граница
меньше нижней, например, если N равно 0. Это вполне допустимо и приведет
к созданию пустого массива. Интересно то, что верхняя граница может быть
меньше чем нижняя граница подтипа индекса.</p>
<p>Неограниченные индексируемые типы очень полезны для аргументов, т. к.
позволяют писать подпрограммы, обрабатывающие массивы любого размера. Мы
рассмотрим примеры позже.</p>
</section>
<section id="id7">
<h2>Установка начальных значений по умолчанию<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h2>
<p>Для устойчивой работы предикатов подтипа (а также инвариантов типа, как
мы увидим далее) может потребоваться, чтобы объект при создании имел
осмысленное начальное значение. Изначально язык Ада предлагал лишь
частичное решение этого вопроса. Для значений ссылочных типов
(«указателей») гарантированно начальное значение в виде null. Для
записей (record) программист может определить значение по умолчанию
следующим образом:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Font</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Arial</span><span class="p">,</span> <span class="nv">Bookman</span><span class="p">,</span> <span class="nv">Times_New_Roman</span><span class="p">);</span>
<span class="kd">type</span> <span class="kt">Size</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">100</span><span class="p">;</span>

<span class="kd">type</span> <span class="kt">Formatted_Character</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">C</span> <span class="p">:</span> <span class="kt">Character</span><span class="p">;</span>
   <span class="n">F</span> <span class="p">:</span> <span class="n">Font</span> <span class="p">:=</span> <span class="n">Times_New_Roman</span><span class="p">;</span>
   <span class="n">S</span> <span class="p">:</span> <span class="n">Size</span> <span class="p">:=</span> <span class="mi">12</span><span class="p">;</span>
<span class="kr">end record</span><span class="p">;</span>

<span class="nl">FC</span> <span class="p">:</span> <span class="kr">For</span><span class="n">matted_Character</span><span class="p">;</span>
<span class="c1">-- Здесь FC.F = Times_New_Roman, FC.S = 12</span>
<span class="c1">-- FC.C не инициализировано</span>
</pre></div>
</div>
<p>К начальным значениям можно относиться по-разному. Есть мнение, что
иметь начальные значения (например, ноль) плохо, поскольку это может
затруднить поиск плавающих ошибок. Контраргумент заключается в том, что
это дает нам уверенность, что объект имеет согласованное начальное
состояние, что может помочь предотвратить разного рода уязвимости.</p>
<p>Как бы то ни было, это довольно странно, что в ранних версиях Ады можно
было задать значения по умолчанию для компонент записи, но нельзя было —
для скалярных типов или массивов. В версии Ада 2012 это было исправлено
при помощи аспектов Default_Value и Default_Component_Value. Новая
версия предыдущего примера может выглядеть так:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Font</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Arial</span><span class="p">,</span> <span class="nv">Bookman</span><span class="p">,</span> <span class="nv">Times_New_Roman</span><span class="p">)</span>
  <span class="kr">with</span> <span class="n">Default_Value</span> <span class="p">=&gt;</span> <span class="n">Times_New_Roman</span><span class="p">;</span>
<span class="kd">type</span> <span class="kt">Size</span> <span class="kr">is</span> <span class="kr">range</span> <span class="mi">1</span> <span class="p">..</span> <span class="mi">100</span>
  <span class="kr">with</span> <span class="n">Default_Value</span> <span class="p">=&gt;</span> <span class="mi">12</span><span class="p">;</span>
</pre></div>
</div>
<p>При таком объявлении типов мы можем опустить начальные значения для
компонент Formatted_Character:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Formatted_Character</span> <span class="kr">is</span> <span class="kr">record</span>
   <span class="n">C</span> <span class="p">:</span> <span class="kt">Character</span><span class="p">;</span>
   <span class="n">F</span> <span class="p">:</span> <span class="n">Font</span><span class="p">;</span>    <span class="c1">--  Times_New_Roman по умолчанию</span>
   <span class="n">S</span> <span class="p">:</span> <span class="n">Size</span><span class="p">;</span>    <span class="c1">--  12 по умолчанию</span>
<span class="kr">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>Для массива можно указать значение по умолчанию для его компонент:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Text</span> <span class="kr">is</span> <span class="kr">new</span> <span class="kt">String</span>
  <span class="kr">with</span> <span class="n">Default_Component_Value</span> <span class="p">=&gt;</span>
    <span class="n">Ada</span><span class="p">.</span><span class="n">Characters</span><span class="p">.</span><span class="n">Latin_1</span><span class="p">.</span><span class="n">Space</span><span class="p">;</span>
</pre></div>
</div>
<p>Следует заметить, что в отличии от начальных значений компонент записи,
здесь используются только статические значения.</p>
</section>
<section id="id8">
<h2>«Вещественные ошибки»<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h2>
<p>Название этого раздела — дословный перевод термина real errors,
обозначающего ошибки округления при работе с вещественными числами. В
оригинале используется как каламбур.</p>
<p>Для операций над числами с плавающей точкой (используя такие типы, как
real в Pascal, float в C и Float в Аде) используется отдельные
вычислительные устройства процессора. При этом, само представление числа
имеет относительную точность. Так в 32 разрядном слове под мантиссу
может быть выделено 23 бита, один бит под знак и 8 бит под экспоненту.
Это дает точность 23 двоичных цифры, т. е. примерно 7 десятичных.</p>
<p>При этом для больших чисел, таких как 123456.7 точность будет в одну
десятую, а для маленьких, как 0.01234567 — восемь знаков после запятой,
но в любом случае число значимых цифр всегда остается 7. Другими
словами, точность связана с величиной значения.</p>
<p>Относительная точность подходит во многих случаях, но не во всех.
Возьмем к примеру представление угла направления траектории корабля или
ракеты. Допустим, мы хотим иметь точность в одну секунду. Полная
окружность включает в себя 360 градусов, в каждом градусе 60 минут, в
каждой минуте 60 секунд.</p>
<p>Если мы храним угол, как число с плавающей точкой:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">bearing</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>тогда для значения 360 градусов точность будет примерно 8 секунд, что
недостаточно, в то время как для 1 градуса — точность 1/45 секунды, что
излишне. Мы могли бы хранить значение, как целое число секунд, используя
целочисленный тип:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">bearingsecs</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Это бы сработало, но нам пришлось бы не забывать выполнять
соответствующее масштабирование каждый раз при вводе и отображении
значения.</p>
<p>Однако, настоящая проблема чисел с плавающей точкой в том, что точность
операций, таких как сложение и вычитание, страдает от ошибок округления.
Если мы находим разницу чисел приблизительно одной величины, мы получим
существенную потерю точности. К тому же некоторые числа не имеют точного
представления. К примеру, у нас есть шаговый двигатель с шагом 1/10
градуса. Мы отмеряем 10 шагов. Но так как 0.1 не имеет точного
представления в двоичной форме, в результате мы никогда не получим ровно
один градус. Таким образом, даже когда нам не требуется высокая
точность, а точность используемого типа больше требуемой, суммарный
эффект множества небольших вычислительных погрешностей может быть
неограничен.</p>
<p>Ручное масштабирование для использования целочисленных типов допустимо в
простых приложениях, но когда у нас несколько таких типов и нам
приходится оперировать ими одновременно начинаются проблемы. Ситуация
еще более усложняется, если применять для масштабирования более быстрые
операции сдвига. Сложность результирующего кода легко может стать
причиной ошибок и затрудняет поддержку. Ада среди тех немногих языков,
которые предоставляют арифметику с фиксированной точкой. По своей сути,
это автоматический вариант масштабирования целых чисел. Так, для
шагового мотора мы могли бы определить:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">Angle</span> <span class="kr">is</span> <span class="n">delata</span> <span class="mf">0.1</span> <span class="kr">range</span> <span class="o">-</span><span class="mf">360.0</span> <span class="p">..</span> <span class="mf">360.0</span><span class="p">;</span>
<span class="kr">for</span> <span class="n">Angle</span><span class="p">&#39;</span><span class="na">Small</span> <span class="kn">use</span> <span class="n">0.1</span><span class="p">;</span>
</pre></div>
</div>
<p>Результат будет представлен в виде масштабированных (с коэффициентом
0.1) значений, хранимых в виде целых чисел. Но нам удобней думать о них
как о соответствующих абстрактных величинах, таких как градусы и их
десятые доли. Такая арифметика не страдает от ошибок округления.</p>
<p>Таким образом, Ада имеет две формы для вещественной арифметики:</p>
<ul class="simple">
<li><p>числа с плавающей точкой имеющие относительную погрешность;</p></li>
<li><p>числа с фиксированной точкой, имеющие абсолютную погрешность.</p></li>
</ul>
<p>Также поддерживается разновидность чисел с фиксированной точкой для
десятичной арифметики — стандартная модель для финансовых расчетов.</p>
<p>Тема этого раздела довольно узкоспециализированная, но она иллюстрирует
размах возможностей языка Ада и особое внимание к поддержке безопасных
численных вычислений.</p>
</section>
</section>


           </div>
          </div>
          


<footer>
      
      

      
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
          
            <a href="chapter_03.html" class="btn btn-neutral float-right" title="Безопасные указатели" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
          
          
            <a href="chapter_01.html" class="btn btn-neutral" title="Безопасный синтаксис" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
          
        </div>
  


  <hr/>

  <div class="legal">
              Copyright &copy; 2022 AdaCore. All rights reserved.
              &nbsp;&nbsp;
              <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
              <br>
              <a href="https://www.adacore.com/company/legal">Legal</a>
              &nbsp; |  &nbsp;
              <a href="https://www.adacore.com/company/privacy">Privacy Policy</a>
              &nbsp; |  &nbsp;
              <a href="https://github.com/AdaCore/learn/issues">Report an Issue</a>
            </div> 

</footer>

        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>
  <button id="scrollToTopBtn" title="Go to top"><i class="fas fa-caret-square-up"></i></button>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
</script>


</body>
</html>